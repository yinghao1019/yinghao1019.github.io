[{"title":"Azure Function 介紹","url":"/az-func-basic/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Azure Functions 是一種無伺服器 (Serverless) 解決方案，目的在於讓開發人員專注於開發業務邏輯的程式，減少維護基礎設施的成本與時間。除了 Azure Function , 其他兩大雲端供應商皆有推出對應的解決方案 (AWS Lambda , Google Cloud Functions) , 各有其優缺點。</p>\n<p>而本篇文章將會帶你認識 Azure function 基礎的觀念，在搭配其他文章來練習實作。</p>\n<h2 id=\"功能介紹\"><a href=\"#功能介紹\" class=\"headerlink\" title=\"功能介紹\"></a>功能介紹</h2><p>Azure Function 是一個在雲端輕鬆執行一小段程式碼或功能的解決方案，你只需要撰寫手頭上問題所需的程式碼，而不需要擔心整個應用程式、執行環境與基礎架構。執行業務程式的單位被稱為 Azure Function App , 可以在 Function App 中撰寫多個不同情境中要執行的程式，如下圖所示。</p>\n<img data-src=\"https://i.imgur.com/JUPIMVq.png\" alt=\"img\" style=\"zoom: 50%;\">\n\n<br>\n\n<p>Azure Function 帶來的優勢與功能有:</p>\n<ol>\n<li><strong>多種語言選擇</strong>：C#、F#、Node.js、Python、PHP、Batch、Bash 或任何可執行程式。 您可以在 Azure Portal 內設定 Azure Function</li>\n<li><strong> 使用付費</strong>：只有程式碼執行期間需要付費。Azure Function 也支援 NuGet 與 NPM，您可以加入自己喜歡的 lib</li>\n<li><strong> 安全性</strong>：透過 OAuth 程序保護 Http 觸發函式 (如： Azure Active Directory，Facebook，Google，Twitter 和 Microsoft 帳戶)</li>\n<li><strong> 簡單整合</strong>：輕鬆地整合 Azure Service 與 SaaS 產品</li>\n<li><strong>靈活開發</strong>：可以在 portal 上編輯程式。或透過 Github、Visual Studio Team Services 和其他支援開發工具設定 持續整合 或 佈署程式碼。</li>\n<li><strong>彈性擴展</strong>:  支援依照需求大小來自動擴展執行 Function 的 host , 在某些方案中還可以調整要擴展的方式</li>\n</ol>\n<h2 id=\"方案說明\"><a href=\"#方案說明\" class=\"headerlink\" title=\"方案說明\"></a>方案說明</h2><p>當你要建立 Azure Function App 專案時，你必須選擇合適的方案 : Consumption Plan , Premium Plan , App Service Plan</p>\n<p>不同的 Plan 提供了多種不同的優勢，請依照自己的需求來決定 Plan, 以下簡單說明各 Plan 的概念，詳情請看官方文件進行比較。</p>\n<ol>\n<li>**Consumption (情況方案)**：預設值。只需支付程式碼執行時間相對的費用，計算單位是以百萬執行來計費。執行期間可以依據需求添加 instance 來自動擴大 CPU 與記憶體。即時在高負載期間也能向外擴展。但缺點為無法與 Azure Virtual Network 整合，因此在管理 ip 的黑白名單較為麻煩。</li>\n<li><strong>Preminum (高級方案)</strong> : 相較於情況方案，提供更好的 instance 選擇來執行 function , 還提供預熱的方法來應對高流量的問題。並且能與 Virtual Network 整合，但費用較為昂貴，是以類似租 vm 的方式進行計算</li>\n<li> **App Service (應用程式方案)**：相較於 Consumption, Premim。 能與其他應用程序共享同個 App Service。也提供設定如何擴展執行 Function 的 Instance , 但費用相較於 Preminum 更為昂貴，但提供更多的資源來執行 Function</li>\n</ol>\n<blockquote>\n<p>請注意，azure function 免費方案的 instance 在經過一段時間未有事件觸發時，會進入休眠狀態，故再次使用功能時會執行效率會比較久 。</p>\n<p>而其他兩種方案都有支援暖機的功能。因此對效能方面有需求的讀者，請斟酌使用對應的方案</p>\n</blockquote>\n<h2 id=\"應用場景與支援\"><a href=\"#應用場景與支援\" class=\"headerlink\" title=\"應用場景與支援\"></a>應用場景與支援</h2><p>Azure Function 也支援多種不同的系統整合，常用來回應事件，如資料庫變更、IoT 資料流、訊息佇列等。以下整理多種不同的應用</p>\n<ul>\n<li>Build a web API</li>\n<li>Process file uploads</li>\n<li>Build a serverless workflow</li>\n<li>Respond to database changes</li>\n<li>Run scheduled tasks</li>\n<li>Create reliable message queue systems</li>\n<li>Analyze IoT data streams</li>\n<li>Process data in real time</li>\n</ul>\n<h3 id=\"範例\"><a href=\"#範例\" class=\"headerlink\" title=\"範例\"></a>範例</h3><ol>\n<li><p>Web application 後端處理： Web App 產生 Request → 將 Request 放入 Service Bus 佇列 → 透過 Azure Function 取出處理後 → 將資料放入 Cosmos DB</p>\n<p><img data-src=\"https://3.bp.blogspot.com/-aiYtyvt_amc/W2cHiMJnTaI/AAAAAAAAgy0/J5imedDEKbkhgUjq4IyhHQ1It5zd8tJJgCLcBGAs/s1600/%25E6%258A%2595%25E5%25BD%25B1%25E7%2589%25871.JPG\" alt=\"img\"></p>\n</li>\n<li><p>即時檔案處理：將 PDF 檔案上傳至 Blob Storage 內 → 透過 Azure Function 處理 → 送至認知服務 (Cognitive Service) 進行處理 → 將取得資訊放入 SQL DB</p>\n<p><img data-src=\"https://2.bp.blogspot.com/-LaV7Tgc-gWY/W2cHiFNH3AI/AAAAAAAAgy4/bmx2C1atCHAx2Yz9qeCEh4hlBVp6eyqOQCLcBGAs/s1600/%25E6%258A%2595%25E5%25BD%25B1%25E7%2589%25872.JPG\" alt=\"img\"></p>\n</li>\n<li><p>自動排程工作：Azure Function 每 15 分鐘清除資料庫重複資料</p>\n</li>\n</ol>\n<p><img data-src=\"https://1.bp.blogspot.com/-PBEuas48vRk/W2cHiWMaiiI/AAAAAAAAgy8/G5PwjEMCHGgfqmJ8w-tohxyaOCFr5dIOQCLcBGAs/s1600/%25E6%258A%2595%25E5%25BD%25B1%25E7%2589%25873.JPG\" alt=\"img\"></p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://www.tpisoftware.com/tpu/articleDetails/1243\">Azure Function 結合 Line Bot 玩出新花樣</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/m/articles/10202960\">Azure Functions⚡介紹及 Serverless 入門輕鬆學</a></li>\n<li><a href=\"https://dotblogs.com.tw/regionbbs/2016/04/01/introduction-to-azure-functions\">Azure Function: 事件驅動式的雲端應用</a></li>\n<li><a href=\"https://hackmd.io/@blueskyson/azure-functions\">初探 Azure Functions</a></li>\n<li><a href=\"https://dog0416.blogspot.com/2018/08/azure-azure-2-webjob-azure-function.html\">Azure 背景處理服務介紹 2 : WebJob 與 Azure Function</a></li>\n</ul>\n","categories":["Azure"],"tags":["Azure","Serverless"]},{"title":"Azure Function 實作教學","url":"/az-func-java/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章專注於教學如何使用 Java 建立 Azure function 專案，從基本的專案環境建置 、如何開發業務邏輯程式、部屬到 Azure Function App 皆會有詳盡的介紹 。幫助讀者快速的了解、建構出 Azure Function 的服務 。</p>\n<p>在開始進行教學前，建議先閱讀 Azure Function 的基本概念會比較好上手:</p>\n<ol>\n<li><a href=\"/az-func-basic/\" title=\"Azure Function 介紹\">Azure Function 介紹</a></li>\n</ol>\n\n<br>\n\n<h2 id=\"開發環境\"><a href=\"#開發環境\" class=\"headerlink\" title=\"開發環境\"></a>開發環境</h2><p>Azure function 支援多種方式 (Maven , Eclipse , Vs Code) 建立專案，而本文選擇使用 Intellj Idea 進行開發:</p>\n<ul>\n<li>JDK 8 , 11 or 17</li>\n<li> 安裝 Maven 3.5.0 +</li>\n<li> 安裝 Azure CLI 2.4 或更新版本</li>\n<li>安裝 Azure Functions Core Tools 4.x 版</li>\n</ul>\n<p>在使用 Intellj 開發前，需安裝額外的外掛程式並登入</p>\n<p>Plugin 搜尋  Azure ToolKit for Intellj  -&gt; 安裝並重啟 -&gt; 上方列選擇 tool  -&gt; azure sign in 讓 local 環境取得雲端資源存取權限</p>\n<img data-src=\"https://i.imgur.com/VSIz5ST.jpg\" style=\"zoom: 60%;\">\n\n<br>\n\n<h2 id=\"建立專案\"><a href=\"#建立專案\" class=\"headerlink\" title=\"建立專案\"></a>建立專案</h2><p>如同建立 spring Boot 專案，在 new project 選擇 Azure Functions 並填入專案相關資訊即可創立。</p>\n<h3 id=\"專案結構\"><a href=\"#專案結構\" class=\"headerlink\" title=\"專案結構\"></a>專案結構</h3><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">FunctionsProject</span><br><span class=\"line\"> | - src</span><br><span class=\"line\"> | | - main</span><br><span class=\"line\"> | | | - java</span><br><span class=\"line\"> | | | | - FunctionApp</span><br><span class=\"line\"> | | | | | - MyFirstFunction.java</span><br><span class=\"line\"> | | | | | - MySecondFunction.java</span><br><span class=\"line\"> | - target</span><br><span class=\"line\"> | | - azure-functions</span><br><span class=\"line\"> | | | - FunctionApp</span><br><span class=\"line\"> | | | | - FunctionApp.jar</span><br><span class=\"line\"> | | | | - host.json</span><br><span class=\"line\"> | | | | - MyFirstFunction</span><br><span class=\"line\"> | | | | | - function.json</span><br><span class=\"line\"> | | | | - MySecondFunction</span><br><span class=\"line\"> | | | | | - function.json</span><br><span class=\"line\"> | | | | - bin</span><br><span class=\"line\"> | | | | - lib</span><br><span class=\"line\"> | - pom.xml</span><br><span class=\"line\"> | - host.json</span><br><span class=\"line\"> | - local.settings.json</span><br></pre></td></tr></tbody></table></figure>\n\n<p>此為 Java 的專案範例結構，由於是透過 maven 進行管理，結構上大致與 Spring Boot 等 Maven 專案結構相同。各資料夾說明如下:</p>\n<ul>\n<li>FunctionApp : 原始碼根目錄。依照業務功能需求可再拆成 sub package 管理，要執行的 Azure Function 也會存放於此。</li>\n<li>host.json :  執行 Azure Function App 的系統參數設定。 ex: log 設定，監控設定，trigger 的全域設定</li>\n<li> local.settings.json : 本機 Debug 模式時所讀取的設定，設定資訊如同 Azure Function 的 App Settings.</li>\n<li>target : 執行 maven 後的打包檔，包含 azure function 對應的資訊，第三方套件等 ….</li>\n</ul>\n<br>\n\n<h2 id=\"範例程式碼說明\"><a href=\"#範例程式碼說明\" class=\"headerlink\" title=\"範例程式碼說明\"></a>範例程式碼說明</h2><p>撰寫程式碼前，Azure Function 有兩個核心的概念需認識:</p>\n<ul>\n<li>Trigger  : 用於設定撰寫的程式碼被觸發的條件，Azure 支援多種不同的方式. Ex: Http , Timer , Queue ,Blob</li>\n<li>Binding : 當希望程式被觸發後有額外的輸入或輸出，可用此功能做設定 </li>\n</ul>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.howhow.functions.handler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.microsoft.azure.functions.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.microsoft.azure.functions.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Optional;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoFunction</span> {</span><br><span class=\"line\">  <span class=\"meta\">@FunctionName(\"QueueOutputPOJOList\")</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> HttpResponseMessage <span class=\"title function_\">QueueOutputPOJOList</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@HttpTrigger(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              name = \"req\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              methods = {HttpMethod.POST},</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              authLevel = AuthorizationLevel.ANONYMOUS)</span></span></span><br><span class=\"line\"><span class=\"params\">          HttpRequestMessage&lt;Optional&lt;String&gt;&gt; request,</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@QueueOutput(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              name = \"itemsOut\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              queueName = \"test-output-java-pojo\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              connection = \"AzureWebJobsStorage\")</span></span></span><br><span class=\"line\"><span class=\"params\">          OutputBinding&lt;List&lt;TestData&gt;&gt; itemsOut,</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"keyword\">final</span> ExecutionContext context)</span> {</span><br><span class=\"line\">    context.getLogger().info(<span class=\"string\">\"Java HTTP trigger processed a request.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">queueMessageId</span> <span class=\"operator\">=</span> request.getBody().orElse(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    itemsOut.setValue(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;TestData&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queueMessageId != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">      <span class=\"type\">TestData</span> <span class=\"variable\">testData1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestData</span>();</span><br><span class=\"line\">      testData1.id = <span class=\"string\">\"msg1\"</span> + queueMessageId;</span><br><span class=\"line\">      <span class=\"type\">TestData</span> <span class=\"variable\">testData2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestData</span>();</span><br><span class=\"line\">      testData2.id = <span class=\"string\">\"msg2\"</span> + queueMessageId;</span><br><span class=\"line\"></span><br><span class=\"line\">      itemsOut.getValue().add(testData1);</span><br><span class=\"line\">      itemsOut.getValue().add(testData2);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> request.createResponseBuilder(HttpStatus.OK).body(<span class=\"string\">\"Hello, \"</span> + queueMessageId).build();</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> request</span><br><span class=\"line\">          .createResponseBuilder(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class=\"line\">          .body(<span class=\"string\">\"Did not find expected items in CosmosDB input list\"</span>)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestData</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String id;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>此範例程式為建立一個 HTTP 端口，並將 Request Body 收到的資料新增至設定 Azure Queue Storage 中</p>\n<ul>\n<li>第 11 行：此 Annotation 用來定義 Function 的名字。 若未使用此標註，則在編譯時就不會產生這個 Function 的 Route </li>\n<li>第 13 行：用於設定該 function 要被哪種條件觸發，每個 function 都需要設定 Trigger 的 Annotation 。 範例中則是透過 HTTP 作為觸發，並綁定 HttpRequestMessage 來取得相關請求資訊</li>\n<li>第 18 行：用於設定該 function 額外的輸入與輸出資訊，每個 Function 可設定 0 至多個 Binding 及相關綁定的參數 .</li>\n</ul>\n<br>\n\n<h3 id=\"讀取Trigger-額外資訊\"><a href=\"#讀取Trigger-額外資訊\" class=\"headerlink\" title=\"讀取Trigger  額外資訊\"></a>讀取 Trigger  額外資訊</h3><p>在業務邏輯程式若需要讀取除了 Trigger  其他的額外資訊，可以透過  <code>@BindingName</code> 來設定要取得的 Trigger meta data. </p>\n<p>各 Trigger 可使用的 Meta data 詳情請查看官方文件</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Function</span> {</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"meta\">@FunctionName(\"metadata\")</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">metadata</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@HttpTrigger(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              name = \"req\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              methods = {HttpMethod.GET, HttpMethod.POST},</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">              authLevel = AuthorizationLevel.ANONYMOUS)</span></span></span><br><span class=\"line\"><span class=\"params\">          Optional&lt;String&gt; body,</span></span><br><span class=\"line\"><span class=\"params\">      <span class=\"meta\">@BindingName(\"name\")</span> String queryValue)</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> body.orElse(queryValue);</span><br><span class=\"line\">  } </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>在上述範例中，<code>queryValue</code> 會取得從 HTTP 請求中的查詢字串參數 <code>name</code>。</p>\n<p>以下是另一個範例，示範如何從 Queue Trigger 取得相關 Message 的 <code>Id</code>。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionName(\"QueueTriggerMetadata\")</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">QueueTriggerMetadata</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@QueueTrigger(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            name = \"message\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            queueName = \"test-input-java-metadata\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            connection = \"AzureWebJobsStorage\")</span></span></span><br><span class=\"line\"><span class=\"params\">        String message,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@BindingName(\"Id\")</span> String metadataId,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@QueueOutput(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            name = \"output\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            queueName = \"test-output-java-metadata\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            connection = \"AzureWebJobsStorage\")</span></span></span><br><span class=\"line\"><span class=\"params\">        OutputBinding&lt;TestData&gt; output,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"keyword\">final</span> ExecutionContext context)</span> {</span><br><span class=\"line\">  context</span><br><span class=\"line\">      .getLogger()</span><br><span class=\"line\">      .info(</span><br><span class=\"line\">          <span class=\"string\">\"Java Queue trigger function processed a message: \"</span></span><br><span class=\"line\">              + message</span><br><span class=\"line\">              + <span class=\"string\">\" with metadaId:\"</span></span><br><span class=\"line\">              + metadataId);</span><br><span class=\"line\">  <span class=\"type\">TestData</span> <span class=\"variable\">testData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestData</span>();</span><br><span class=\"line\">  testData.id = metadataId;</span><br><span class=\"line\">  output.setValue(testData);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h3 id=\"Log-輸出\"><a href=\"#Log-輸出\" class=\"headerlink\" title=\"Log 輸出\"></a>Log 輸出</h3><p>如果要在程式寫入 Log 資訊，則是透過 ExecutionContext <code>中定義的</code> getLogger 。而 Execution Context 除了 Logger, 也能取得其他額外資訊，詳請請看官方文件</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">echo</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@HttpTrigger(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            name = \"req\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            methods = {HttpMethod.POST},</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            authLevel = AuthorizationLevel.ANONYMOUS)</span></span></span><br><span class=\"line\"><span class=\"params\">        String req,</span></span><br><span class=\"line\"><span class=\"params\">    ExecutionContext context)</span> {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (req.isEmpty()) {</span><br><span class=\"line\">    context</span><br><span class=\"line\">        .getLogger()</span><br><span class=\"line\">        .warning(</span><br><span class=\"line\">            <span class=\"string\">\"Empty request body received by function \"</span></span><br><span class=\"line\">                + context.getFunctionName()</span><br><span class=\"line\">                + <span class=\"string\">\" with invocation \"</span></span><br><span class=\"line\">                + context.getInvocationId());</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> String.format(req);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h3 id=\"讀取外部參數-、環境變數\"><a href=\"#讀取外部參數-、環境變數\" class=\"headerlink\" title=\"讀取外部參數 、環境變數\"></a>讀取外部參數 、環境變數</h3><p>在專案開發中，有些設定會依照不同環境來變動，像是連線，認證資訊 等 。這些資訊通常都會設定在 App Settings , </p>\n<p>App Settings 的資訊在執行期間會被視為環境變數，因此可使用 <code>System.getenv(\"AzureWebJobsStorage\")</code> 來存取這些設定。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">echo</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@HttpTrigger(</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            name = \"req\",</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            methods = {HttpMethod.POST},</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"params\">            authLevel = AuthorizationLevel.ANONYMOUS)</span></span></span><br><span class=\"line\"><span class=\"params\">        String req,</span></span><br><span class=\"line\"><span class=\"params\">    ExecutionContext context)</span> {</span><br><span class=\"line\">  context.getLogger().info(<span class=\"string\">\"My app setting value: \"</span> + System.getenv(<span class=\"string\">\"myAppSetting\"</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> String.format(req);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"測試與除錯\"><a href=\"#測試與除錯\" class=\"headerlink\" title=\"測試與除錯\"></a>測試與除錯</h2><h3 id=\"Plugin-Debug\"><a href=\"#Plugin-Debug\" class=\"headerlink\" title=\"Plugin Debug\"></a>Plugin Debug</h3><p>Intellj 的 Azure Plugin 支援本機 Debug  , 用法如同 SpringBoot 除錯，會模擬一個 service 來進行除錯。</p>\n<p>但在本機除錯時，plugin 會存取專案根目錄中的 <code>local .settings.json</code> 來做為 App Setting </p>\n<ol>\n<li><p>在執行除錯前，可至 設定中調整要讀取的 App Setting  , 此服務佔用的 port 或 jvm 相關的參數</p>\n<img data-src=\"https://i.imgur.com/S1pEGzd.png\" alt=\"image-20240108112756092\" style=\"zoom:50%;\">\n</li>\n<li><p>設定中斷點後執行 Debug , 即可查看該中斷點以前的資訊</p>\n<img data-src=\"https://i.imgur.com/XVbtEdF.jpg\" style=\"zoom:50%;\"></li>\n</ol>\n<h3 id=\"手動觸發Function\"><a href=\"#手動觸發Function\" class=\"headerlink\" title=\"手動觸發Function\"></a>手動觸發 Function</h3><p>開發的 Azure Function 條件若需要在特定情境中才能被觸發，但這個情境又難以達成時，可以透過發送 HTTP 請求的方式來進行觸發。</p>\n<p>Ex: 排程，Queue ,Blob</p>\n<ol>\n<li><p>設定要觸發 Function 的端點，規則如下:</p>\n<p><img data-src=\"https://learn.microsoft.com/en-us/azure/azure-functions/media/functions-manually-run-non-http/azure-functions-admin-url-anatomy.png\" alt=\"Define the request location: host name + folder path + function name\"></p>\n<ul>\n<li><p>hostname : 設定你的 function  網域名稱。本機的話就是 Localhost</p>\n</li>\n<li><p>Function Name : 使用 @FunctionName 設定的名字</p>\n</li>\n<li><p>HTTP method : 方法統一採用 POST , content-type 則是 application/json</p>\n</li>\n<li><p>認證資訊：部屬的 function 因資安考量，不會開放給所有人觸發。因此需從 function 取得 Mater key 並在 Http Header 中設定</p>\n<p>x-functions-key</p>\n</li>\n</ul>\n</li>\n<li><p>設定要帶的參數</p>\n<p>有些 Trigger 會綁定一些輸入資訊，此時在 Body 中帶入 {“input”:”${相關資訊}”}</p>\n<p><img data-src=\"https://learn.microsoft.com/en-us/azure/azure-functions/media/functions-manually-run-non-http/functions-manually-run-non-http-body.png\" alt=\"Postman body settings.\"></p>\n</li>\n<li><p>如果有成功回應，代表 function 被觸發</p>\n<p><img data-src=\"https://learn.microsoft.com/en-us/azure/azure-functions/media/functions-manually-run-non-http/functions-manually-run-non-http-send.png\" alt=\"Send a request with Postman.\"></p>\n</li>\n</ol>\n<br>\n\n<h2 id=\"部屬到-Azure-Function-App\"><a href=\"#部屬到-Azure-Function-App\" class=\"headerlink\" title=\"部屬到 Azure Function  App\"></a>部屬到 Azure Function  App</h2><p>Azure Function 支援多種部屬方式，包括持續，手動部屬的選項。同時也支援容器化的部屬方法</p>\n<p><strong>CD (持續部屬)</strong></p>\n<ul>\n<li>GitHub Action</li>\n<li>Azure Pipeline</li>\n<li>Jenkins</li>\n</ul>\n<p><strong>手動部屬</strong></p>\n<ul>\n<li>Azure CLI</li>\n<li>REST API</li>\n<li>Containers</li>\n</ul>\n<p>本篇文章僅會教學使用 GitHub Action 完成 CD , 使用 Azure CLI 手動部屬的方法，剩下的方法請參照<a href=\"https://learn.microsoft.com/en-us/azure/azure-functions/functions-continuous-deployment\">官方文件閱讀</a> </p>\n<h3 id=\"GitHub-Action\"><a href=\"#GitHub-Action\" class=\"headerlink\" title=\"GitHub Action\"></a>GitHub Action</h3><ol>\n<li><p>設定 GitHub Workflow 能存取 Azure Function 資源的權限</p>\n<ul>\n<li><p>下載 publish profile </p>\n</li>\n<li><p>於 Github Secret 中新增 <code>AZURE_FUNCTIONAPP_PUBLISH_PROFILE</code> 變數，並將 <code>publish profile</code> 的內容貼至對應的值中</p>\n<p><img data-src=\"https://learn.microsoft.com/zh-tw/azure/azure-functions/media/functions-how-to-github-actions/get-publish-profile.png\" alt=\"Download publish profile\"></p>\n<br></li>\n</ul>\n</li>\n<li><p>於專案路徑 <code>/.github/workflows/</code> 設定 github workflow 的 Yaml 檔 </p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">Java</span> <span class=\"string\">project</span> <span class=\"string\">to</span> <span class=\"string\">Azure</span> <span class=\"string\">Function</span> <span class=\"string\">App</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">main</span></span><br><span class=\"line\">  <span class=\"attr\">workflow_dispatch:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">env:</span></span><br><span class=\"line\">  <span class=\"attr\">AZURE_FUNCTIONAPP_NAME:</span> <span class=\"string\">'your-app-name'</span>   <span class=\"comment\"># set this to your function app name on Azure</span></span><br><span class=\"line\">  <span class=\"attr\">POM_XML_DIRECTORY:</span> <span class=\"string\">'.'</span>                    <span class=\"comment\"># set this to the directory which contains pom.xml file</span></span><br><span class=\"line\">  <span class=\"attr\">JAVA_VERSION:</span> <span class=\"string\">'8'</span>                         <span class=\"comment\"># set this to the java version to use (e.g. '8', '11', '17')</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">build-and-deploy:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">windows-latest</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span> <span class=\"string\">dev</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">'Checkout GitHub Action'</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Setup</span> <span class=\"string\">Java</span> <span class=\"string\">Sdk</span> <span class=\"string\">${{</span> <span class=\"string\">env.JAVA_VERSION</span> <span class=\"string\">}}</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-java@v1</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">java-version:</span> <span class=\"string\">${{</span> <span class=\"string\">env.JAVA_VERSION</span> <span class=\"string\">}}</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">'Restore Project Dependencies Using Mvn'</span></span><br><span class=\"line\">      <span class=\"attr\">shell:</span> <span class=\"string\">pwsh</span></span><br><span class=\"line\">      <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">        pushd './${{ env.POM_XML_DIRECTORY }}'</span></span><br><span class=\"line\"><span class=\"string\">        mvn clean package</span></span><br><span class=\"line\"><span class=\"string\">        popd</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">'Run Azure Functions Action'</span></span><br><span class=\"line\">      <span class=\"attr\">uses:</span> <span class=\"string\">Azure/functions-action@v1</span></span><br><span class=\"line\">      <span class=\"attr\">id:</span> <span class=\"string\">fa</span></span><br><span class=\"line\">      <span class=\"attr\">with:</span></span><br><span class=\"line\">        <span class=\"attr\">app-name:</span> <span class=\"string\">${{</span> <span class=\"string\">env.AZURE_FUNCTIONAPP_NAME</span> <span class=\"string\">}}</span></span><br><span class=\"line\">        <span class=\"attr\">package:</span> <span class=\"string\">'$<span class=\"template-variable\">{{ env.POM_XML_DIRECTORY }}</span>'</span> <span class=\"comment\"># if there are multiple function apps in same project, then this path will be like './${{ env.POM_XML_DIRECTORY }}/target/azure-functions/${{ env.POM_FUNCTIONAPP_NAME }'</span></span><br><span class=\"line\">        <span class=\"attr\">publish-profile:</span> <span class=\"string\">${{</span> <span class=\"string\">secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE</span> <span class=\"string\">}}</span></span><br><span class=\"line\">        <span class=\"attr\">respect-pom-xml:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>於 Action 上檢視是否成功執行</p>\n<img data-src=\"https://i.imgur.com/z6ykzr2.jpg\" style=\"zoom:60%;\"></li>\n</ol>\n<h3 id=\"Azure-CLI-部屬\"><a href=\"#Azure-CLI-部屬\" class=\"headerlink\" title=\"Azure CLI 部屬\"></a>Azure CLI 部屬</h3><ol>\n<li><p>執行 mvn clean install 打包專案</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">mvn clean install</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>將<code>./target/azure-functions</code>  中的 project 資料夾轉成 zip 檔</p>\n</li>\n<li><p>執行 Azure cli 的以下指令進行部屬</p>\n<ul>\n<li>-g : function 的 resource group</li>\n<li>-n: function app 的 name</li>\n<li>–src: 本機 zip 檔的位置 </li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">az functionapp deployment <span class=\"built_in\">source</span> config-zip -g &lt;resource_group&gt; -n \\</span><br><span class=\"line\">&lt;app_name&gt; --src &lt;zip_file_path&gt;</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>登入 azure portal 查看部屬情況</p>\n<img data-src=\"https://i.imgur.com/P42ILM9.jpg\" style=\"zoom:50%;\"></li>\n</ol>\n<br>\n\n<h2 id=\"監控-Azure-Function\"><a href=\"#監控-Azure-Function\" class=\"headerlink\" title=\"監控 Azure Function\"></a>監控 Azure Function</h2><p>當程式上線後，若發生重大異常，錯誤，開發人員很難去得知。因此 Azure Function 提供整合 Application Insight 的方法來進行持續監控，</p>\n<p>透過設定好的預警門檻，來觸發對應的信件通知系統來完成自動化的監控。</p>\n<p> 筆者將會於下篇文章教學如何實現 Azure function 整合 Application insight 的監控功能。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://learn.microsoft.com/en-us/azure/azure-functions/functions-continuous-deployment\">Continuous deployment for Azure Functions</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-java?tabs=bash,consumption\">Azure Functions Java developer guide</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/azure/azure-functions/functions-create-maven-intellij\">Create your first Java function in Azure using IntelliJ</a></li>\n<li><a href=\"https://hackmd.io/@blueskyson/azure-functions#%E5%B8%83%E7%BD%B2%E5%88%B0-Azure-Functions\">初探 Azure Functions</a></li>\n</ul>\n","categories":["Azure"],"tags":["Azure","Serverless","Java"]},{"title":"Azure Queue Storage 介紹與操作","url":"/azure-queue/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Azure Queue Storage 適合用於儲存大量的訊息，但又不會需要長期保存時的情境，一個 Queus Storage 可以純存約百萬則訊息，</p>\n<p>存取訊息的方式支援 HTTP 與 HTTPS 。 如果要使用 Azure Queue Storage, 則需在 Azure Storage Account 中進行建立與管理。</p>\n<p><img data-src=\"https://3.bp.blogspot.com/-bykMEF0qNHA/WwqssskmT4I/AAAAAAAAgJM/2ujpeckpHlskoBXWooE-Ry5lKaEJ8OuIACLcBGAs/s640/801.jpg\" alt=\"Azure Queue\"></p>\n<br>\n\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><h3 id=\"Azure-Queue-Storage\"><a href=\"#Azure-Queue-Storage\" class=\"headerlink\" title=\"Azure Queue Storage\"></a><strong>Azure Queue Storage</strong></h3><ul>\n<li>FIFO : 先儲存的會優先被取出來處理，但由於是軟刪除，所以發生 concurrency 不一定會保持此特性</li>\n<li>每一筆訊息最大容量為 64 KB , 儲存期限為 7 天</li>\n<li>一個 queue 可容納 500TB 的資訊</li>\n<li>易於與 Azure 其他服務整合，擴張 (Azure Function)</li>\n<li> 支援 HTTP ,HTTPS 通訊協定存取</li>\n</ul>\n<h3 id=\"儲存的訊息\"><a href=\"#儲存的訊息\" class=\"headerlink\" title=\"儲存的訊息\"></a><strong>儲存的訊息</strong></h3><ul>\n<li>可以是 UTF -8 字串 或是 二進位制 (Byte Arrays) 的格式</li>\n<li> XML 文件，CSV ,TSV 檔案等</li>\n</ul>\n<br>\n\n<h2 id=\"應用時機\"><a href=\"#應用時機\" class=\"headerlink\" title=\"應用時機\"></a>應用時機</h2><p><img data-src=\"https://i.imgur.com/TjyUGl1.jpg\" alt=\"image-20240105162500590\"></p>\n<p>主要被應用在於非即時回應的非同步處理，想降低不同系統之間的耦合性，或是做為後端伺服器的系統緩衝。</p>\n<ul>\n<li>Email , SMS 的訊息發送</li>\n<li>後端 Server 紀錄 Log 資料的管道</li>\n<li>微服務系統之間的溝通橋樑</li>\n</ul>\n<br>\n\n<h2 id=\"實作介紹\"><a href=\"#實作介紹\" class=\"headerlink\" title=\"實作介紹\"></a>實作介紹</h2><p>因為筆者主要使用 Java 開發，接下來 Queue 的實作皆會已 Java 語法進行介紹常用的操作:</p>\n<ol>\n<li>Storage Account 建立 Queue</li>\n<li> 設定 Queue 連線與授權資訊</li>\n<li>傳送訊息至 Queue</li>\n<li> 取出 Queue 中的訊息</li>\n<li>更新 Queue 的訊息</li>\n<li>刪除 Queue 的訊息</li>\n<li>計算 Queue 中訊息的數量</li>\n<li> Queue 的例外處理</li>\n</ol>\n<br>\n\n<ol>\n<li> Storage Account 建立 Queue</li>\n</ol>\n<p>   登入 Azure Portal 後，選擇 Storage Account , 點選側邊欄的 Queue 後按上面的 + 進行新增</p>\n   <img data-src=\"https://i.imgur.com/gTzIb8f.png\" alt=\"azure-portal\" style=\"zoom:67%;\">\n\n<ol start=\"2\">\n<li><p>設定 Queue 連線與授權資訊</p>\n<p>設定 Queue 服務的 url 與認證方式，認證方式主要有三種 (分別為 SAS Token , Connection String , Storage Account Key) , </p>\n<p>取得認證資訊方式可參考官方文件 <a href=\"https://learn.microsoft.com/en-us/java/api/overview/azure/storage-queue-readme?view=azure-java-stable#enqueue-message-into-a-queue\">Authenticate the client</a> </p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net/%s\"</span>, ACCOUNT_NAME, queueName);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).buildClient();</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>傳送訊息至 Queue</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\"></span><br><span class=\"line\">queueClient.sendMessage(<span class=\"string\">\"myMessage\"</span>);</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>取出 Queue 中的訊息</p>\n<p>取出 Queue 的 Message 有提供其他額外參數設定，由以下多做說明:</p>\n<ul>\n<li>maxMessages: 批次從 queue 中取出訊息的最大數量 。最大為 32 筆，超過設定會出現 exception </li>\n<li>visibilityTimeout: 取出後隔多少時間才能再次看到該 Message, 預設為 30 秒</li>\n<li> timeout: 與 queue 連線多久沒回應的時效限制</li>\n<li> context: 使用服務前，需要額外新增近 Http Pipeline 的資訊 </li>\n</ul>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\">queueClient.receiveMessages(<span class=\"number\">10</span>).forEach(message -&gt;</span><br><span class=\"line\">    System.out.println(message.getBody().toString()));</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>更新 Queue 的訊息</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @param messageId: Message 的Id</span></span><br><span class=\"line\"><span class=\"comment\">// @param popReceipt: 用於辨識哪個Message 要被更新</span></span><br><span class=\"line\"><span class=\"comment\">// @param visibilityTimeout: 更新後多久才能再看到</span></span><br><span class=\"line\">queueClient.updateMessage(messageId, popReceipt, <span class=\"string\">\"new message\"</span>, visibilityTimeout);</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>刪除 Queue 的訊息</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\"></span><br><span class=\"line\">queueClient.deleteMessage(messageId, popReceipt);</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>計算 Queue 中訊息的數量</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        QueueUtils.createQueueClient(queueName, QueueUtils.getDefaultConnString());</span><br><span class=\"line\">queueClient.getProperties().getApproximateMessagesCount();</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>Queue 的例外處理</p>\n<p>Azure SDK 有提供額外的 Error Code 讓開發人員進行處理，詳情請見 <a href=\"https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-error-codes\">Queue Storage error codes</a></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueServiceURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueServiceClient</span> <span class=\"variable\">queueServiceClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueServiceClientBuilder</span>().endpoint(queueServiceURL)</span><br><span class=\"line\">    .sasToken(SAS_TOKEN).buildClient();</span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">    queueServiceClient.createQueue(<span class=\"string\">\"myQueue\"</span>);</span><br><span class=\"line\">} <span class=\"keyword\">catch</span> (QueueStorageException e) {</span><br><span class=\"line\">    logger.error(<span class=\"string\">\"Failed to create a queue with error code: \"</span> + e.getErrorCode());</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<br>\n\n<h2 id=\"補充說明\"><a href=\"#補充說明\" class=\"headerlink\" title=\"補充說明\"></a>補充說明</h2><p>除了 Azure Queue Storage , 微軟雲端有再推出另外一種 Queue 型態的服務 - Azure Service Bus 。相較於 Queue Storage , Service Bus 的功能與 Rabbit MQ , Kafaka , GCP PubSub  較為類似，比較偏向 Producer - Consumer 的架構，所以如果希望要較為即時的非同步處理功能，請珍惜生命，不要走錯棚！</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://dog0416.blogspot.com/2018/05/azure-azure-queue-storage.html\">Azure Queue Storage 介紹與操作</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10205084\">Azure Queue Storage 介紹 - IT 幫幫忙</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/java/api/overview/azure/storage-queue-readme?view=azure-java-stable#enqueue-message-into-a-queue\">Azure Storage Queue client library for Java</a></li>\n</ul>\n","categories":["Azure"],"tags":["Azure","Java","Queue","Async"]},{"title":"Google Cloud Pub/Sub Console 操作","url":"/gcp-pubsub-gui/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章主要介紹如何透過 GCP 提供的 Console 介面來操作 Pub / Sub 服務，如果對 Pub/Sub 的概念還不熟悉的朋友，</p>\n<p>建議可以閱讀以下的文章進行了解.</p>\n<ol>\n<li><a href=\"/gcp-pubsub/\" title=\"Google Cloud Pub/Sub 介紹\">Google Cloud Pub/Sub 介紹</a></li>\n</ol>\n\n<h2 id=\"啟用Pub-Sub-管理功能\"><a href=\"#啟用Pub-Sub-管理功能\" class=\"headerlink\" title=\"啟用Pub/Sub 管理功能\"></a>啟用 Pub/Sub 管理功能</h2><p>按一下側邊攔，把 Pub/Sub 功能找出來</p>\n<p><img data-src=\"/\"></p>\n<h2 id=\"設定主題-Topic\"><a href=\"#設定主題-Topic\" class=\"headerlink\" title=\"設定主題 (Topic)\"></a>設定主題 (Topic)</h2><ol>\n<li><p>進入 Pub/Sub 管理頁面有，找到主題 (Topic)，選建立主題</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>設定一下主題名稱，名稱會變成一個主題 ID 提供訂閱使用 /project/ 專案名稱 /topics/ 主題名稱</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>確認一下主題生成的狀態</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>點進去 Topic 名稱後可以看狀態</p>\n<p><img data-src=\"/\"></p>\n</li>\n</ol>\n<h2 id=\"設定訂閱項目-Subscription\"><a href=\"#設定訂閱項目-Subscription\" class=\"headerlink\" title=\"設定訂閱項目 (Subscription)\"></a>設定訂閱項目 (Subscription)</h2><p>設定 Subscription 作為接受 Topic 傳遞訊息的監聽項目，本身有提供篩選機制來接收特內容的訊息。</p>\n<p>後續的其他系統整合時也是去監聽 Subscription 有無收到 Topic 傳來的資料 (Subscriber)</p>\n<ol>\n<li><p>進入 Pub/Sub 管理頁面有，找到訂閱項目 (Subscription)，選建立訂閱項目</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>設定訂閱項目</p>\n<ul>\n<li><p>訂閱項目名稱：會生成訂閱項目 ID <code>projects/專案名稱/subscriotions</code></p>\n</li>\n<li><p>選取 Cloud Pub/Sub 主題：選擇訂閱的 Topic 主題 (這邊就選剛剛的 Topic 做測試)</p>\n</li>\n<li><p>傳送類型:</p>\n<ul>\n<li>提取：程式去提取資料個概念</li>\n<li>推送：設定一個 https 基底的 API 提供給 subscription 在接收資料時呼叫使用，也可適用於 GCP 內部服務開出的 API (如: Cloud Run, GKE, GCS, GCE)</li>\n</ul>\n</li>\n<li><p> 訂閱項目有效期：訂閱項目的活躍保留天數 (多久沒傳遞訊息，之後會自動刪除的天數)</p>\n</li>\n<li><p>確認期限：訊息被 subscriber 捕抓或是提取後，需要多久的反應回饋時間，從提取到確認的時間差 (確認服務處理的狀態)，這邊可以作為事件被提取後，作完後續流程的確認，超過時間差就會返回到 Message Pool，提供給其他 Subscriber 提取實作。</p>\n</li>\n<li><p>訂閱項目篩選器：篩選你的訊息內容，之後才抓進來到你的 subscription 之中</p>\n<ul>\n<li><code>attributes.&lt;item-name&gt; = &lt;item-info&gt;</code></li>\n<li><code>hasPrefix(&lt;item-name&gt;, &lt;item-info&gt;)</code></li>\n</ul>\n</li>\n<li><p>訊息保留時間：訊息被發送後，到 subscription 且未被 subscriber 提取或是使用，保留在 Message Pool 的時間</p>\n</li>\n<li><p>無效信件：他會轉發你的訊息到其他的 topic 之上的設定</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://ithelp.ithome.com.tw/users/20121070/ironman/3552\">基於付費公有雲與開源機房自建私有雲之雲端應用服務測試兼叢集與機房託管服務實戰之勇者崎嶇波折且劍還掉在路上的試煉之路</a></li>\n</ul>\n","categories":["GCP"],"tags":["Async","Message Queue","GCP"]},{"title":"Google Cloud Pub/Sub 介紹","url":"/gcp-pubsub/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Cloud Pub/Sub 為 Google 推出的 message service，主要用途是讓每個獨立的應用 (Application) 間能透過 Publish-Subscribe 的模式來進行訊息交換與溝通，一般而言利用 message service<br>當作中介層 (Middleware) 來傳遞訊息，有著以下幾項優 / 缺點:</p>\n<br>\n\n<h3 id=\"優點\"><a href=\"#優點\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li>透過非同步的訊息傳遞，降低 Publisher、Subscriber 間的耦合度。意即彼此間無需知道對方位置，亦不會任意一方出現問題而導致連鎖反應。</li>\n<li>當作訊息緩衝區 (Buffer)，避免後端消化速度不夠快而無法接收新進的訊息請求。</li>\n<li>根據不同用途來訂閱 / 散佈訊息。</li>\n</ul>\n<h3 id=\"缺點\"><a href=\"#缺點\" class=\"headerlink\" title=\"缺點\"></a><strong>缺點</strong></h3><ul>\n<li><p>由於是非同步處理，因此訊息的即時性 / 順序性 / 重覆性無法受到保證。</p>\n</li>\n<li><p>需要熟悉 message service 服務的遞送流程，避免異常或訊息無法正確傳送。</p>\n<br></li>\n</ul>\n<p>就先前經驗來說，一個高可用 / 彈性的 message service，通常會考慮以下幾點:</p>\n<ul>\n<li>訊息傳遞效率</li>\n<li>可擴展性 (Scalability)、可靠性 (Reliability)、可用性 (Availability)</li>\n</ul>\n<p>為方便開發者瞭解及使用，Cloud Pub/Sub 將 AMQP (<a href=\"https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol\">Advanced Message Queuing Protocol</a>)  中 Message Broker、Exchange、Queue 等不會直接被開發者接觸的部分隱藏起來大幅降低進入門檻，開發者僅需要瞭解 Topic、Publisher、Subscriber、Push/Pull Subscription 即可撰寫相關程式。</p>\n<br>\n\n<h2 id=\"架構介紹\"><a href=\"#架構介紹\" class=\"headerlink\" title=\"架構介紹\"></a>架構介紹</h2><h3 id=\"❖主要名詞認識\"><a href=\"#❖主要名詞認識\" class=\"headerlink\" title=\"❖主要名詞認識\"></a><em><strong>❖主要名詞認識</strong></em></h3><ul>\n<li><p><strong>Message</strong>: 要傳送的 data</p>\n</li>\n<li><p><strong>Topic</strong>: 主題，是一個可以被訂閱訊息的實體</p>\n</li>\n<li><p><strong>Subscription</strong>: 訂閱，連結 Topic 跟 Subscriber 之間的實體，接收以及處理發佈訊息到 Topic</p>\n</li>\n<li><p><strong>Publisher</strong>: 發布者，提供並且發送訊息到 Topic 的單位</p>\n</li>\n<li><p><strong>Subscriber</strong>: 訂閱者， 訂閱訊息的一個單位</p>\n<br></li>\n</ul>\n<h3 id=\"❖系統流程\"><a href=\"#❖系統流程\" class=\"headerlink\" title=\"❖系統流程\"></a><strong>❖系統流程</strong></h3><p><img data-src=\"https://i.imgur.com/TsAvWUi.png\"></p>\n<p>上圖為 <a href=\"https://cloud.google.com/pubsub/docs/overview\">Google 官方</a> 介紹 Pub/Sub 的流程，主要流程如下:</p>\n<ol>\n<li>Publisher 首先在 Cloud Pub/Sub 建立傳訊息用的 Topic，然後開始向該 Topic 傳送訊息</li>\n<li>當訊息被接收前或尚未收到 Acknowledge (Ack) 時，會被保存起來並等待在次傳送出去</li>\n<li> Subscriber 向服務註冊訂閱 (Subscription) 後，所有發送到 Topic 的訊息會轉發給該 Topic 下的所有 Subscriber</li>\n<li>Subscriber 收到訊息後會回傳 Ack 訊息給 Cloud Pub/Sub，以確認訊息已經收到</li>\n<li>當 Ack 被 Cloud Pub/Sub 收到後，將該訊息自 Message Storage 刪除</li>\n</ol>\n<br>\n\n<h3 id=\"❖情境案例\"><a href=\"#❖情境案例\" class=\"headerlink\" title=\"❖情境案例\"></a><strong>❖情境案例</strong></h3><p><img data-src=\"https://i.imgur.com/7latY55.png\"></p>\n<ul>\n<li>A, B 同時可以 publish message 到相同的 Topic</li>\n<li>subcriber 可以同時接收多個 subscription 傳遞來的 Message</li>\n<li>Topic 可以有多個 subscription</li>\n</ul>\n<br>\n\n<h2 id=\"SubScription\"><a href=\"#SubScription\" class=\"headerlink\" title=\"SubScription\"></a>SubScription</h2><h3 id=\"❖操作方式\"><a href=\"#❖操作方式\" class=\"headerlink\" title=\"❖操作方式\"></a><strong>❖操作方式</strong></h3><p><strong>對訂閱者來說有兩種處理 Message 的方式，分別為 PULL 跟 PUSH.</strong></p>\n<ul>\n<li><code>[push](&lt;https://cloud.google.com/pubsub/docs/push&gt;)</code></li>\n<li>送一個 request 給 App 的 endpoint 說我要傳訊息來。</li>\n<li>以這個 endpoint return <code>[200, 201, 204, or 102]</code> 來判定為 ack, 如果不是就會一直被打直到這個訂閱所設置的最大 retention time 為止</li>\n<li>動態調整 push 的 request，根據拿到的狀態碼來調整。</li>\n<li><code>[pull](&lt;https://cloud.google.com/pubsub/docs/pull&gt;)</code></li>\n<li>視為被動的取得訂閱佇列 (subscription queue) 中的 Message</li>\n</ul>\n<p><strong>兩者機制要怎麼選用，有以下建議</strong></p>\n<ul>\n<li><code>push</code></li>\n<li>低流量情形 (&lt;10,000/second)</li>\n<li>Legacy push webhook</li>\n<li>App Engine 的訂閱者</li>\n<li><code>pull</code></li>\n<li>大量的訊息 (many more than 1/second)</li>\n<li> 效能跟訊息遞送因素很重視者</li>\n<li>公開的 Https Endpoint</li>\n</ul>\n<br>\n\n<h3 id=\"❖生命週期\"><a href=\"#❖生命週期\" class=\"headerlink\" title=\"❖生命週期\"></a><strong>❖生命週期</strong></h3><ul>\n<li>31 天內沒有被 pull or push 就會被自動刪除，或者經過手動操作被刪除</li>\n<li>訂閱的名字沒有絕對關係，用同樣的名字也會被視為兩者不同的訂閱 (情境可能是：刪除前，刪除後)</li>\n<li> 刪除後就算有大量還沒寄出的訊息，或者是 Backlog，都與新建立的無關</li>\n</ul>\n<br>\n\n<h2 id=\"注意事項\"><a href=\"#注意事項\" class=\"headerlink\" title=\"注意事項\"></a>注意事項</h2><p>使用 Cloud Pub/Sub 時需要小心以下幾點：</p>\n<ul>\n<li>若 Ack 因為意外或超時而尚未傳到 Cloud Pub/Sub 時該訊息會至多保留 7 天 (請參考 <a href=\"https://cloud.google.com/pubsub/docs/subscriber\">Retry Policy</a>)，因此程式撰寫時需考慮到訊息延遲遞送的問題，比方說加上時間戳來過濾超時的訊息。</li>\n<li>為求傳遞效能，服務不保證訊息的順序性</li>\n<li>訊息可能會發生重覆 (duplicate) 的情況，面對訊息重覆有兩種處理方式<ul>\n<li>若該請求<code>不能</code>重覆執行 (比方說銀行扣款)，就需要針對訊息夾帶的 uuid 進行重覆性確認</li>\n<li>若該請求<code>可以</code>重覆執行 (比方說查看銀行餘額)，程式便能忽略重覆性確認的流程，除非重覆次數太多導致系統性能受到影響</li>\n</ul>\n</li>\n<li>訊息在尚未接收完畢前切勿刪除該 Topic ，避免 Subscriber 無法接收其他存留的訊息</li>\n<li>建議 Subscriber 在起來時，產生其專用的 uuid 用來向服務註冊訂閱，避免名稱衝突</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://cloud.google.com/pubsub/docs/overview\">Google Pubsub 官方文件</a></li>\n<li><a href=\"https://tachingchen.com/tw/blog/google-cloud-pubsub-introduction/\">初探 Google Cloud Pub/Sub</a></li>\n<li><a href=\"https://kylinyu.win/pubsub/#-subscriber-%E6%93%8D%E4%BD%9C%E9%9D%A2\">認識 Google Cloud Pub/Sub</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10206624\">GCP 事件觸發驅動訊息推播 - Cloud Pub/Sub</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10249308\">GCP 公有雲_雲端事件消息傳遞服務實戰 - Pub/Sub 組建測試之路</a></li>\n</ul>\n","categories":["GCP"],"tags":["Async","Message Queue","GCP"]},{"title":"Java Apache HttpClient4.X Connection Reset 問題","url":"/http-client-conn-reset/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>若要透過 Java 呼叫 API 端點， 可透過多種不同的程式工具進行呼叫，像是 Apache HTTP Client 、OkHTTP、WevFlux 等。今天將介紹使用 Apache HTTP  Client 開發所遇到的坑，以及對應的解決辦法。</p>\n<h2 id=\"發生原因\"><a href=\"#發生原因\" class=\"headerlink\" title=\"發生原因\"></a>發生原因</h2><p>由於因業務邏輯需求要呼叫多次 API 。可能會重複使用建立的 HTTP Client Instance 來去呼叫 API, 若 API 的時間連線時間太長， 可能會出現 TCP Idle connection ， 導致程式無法順利執行完成，拋出 Socket Exception:  Connection Reset 問題</p>\n<p>以下為發生的程式碼範例</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException {</span><br><span class=\"line\">        <span class=\"type\">HttpClientBuilder</span> <span class=\"variable\">httpClientBuilder</span> <span class=\"operator\">=</span> HttpClientBuilder.create();</span><br><span class=\"line\">        List&lt;String&gt; urlList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//  multiple urls using single HttpClient</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">CloseableHttpClient</span> <span class=\"variable\">httpClient</span> <span class=\"operator\">=</span> httpClientBuilder.build()) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String url : urlList) {</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">HttpGet</span> <span class=\"variable\">getRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpGet</span>(url);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> (<span class=\"type\">CloseableHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> httpClient.execute(getRequest)) {</span><br><span class=\"line\">                    <span class=\"type\">HttpEntity</span> <span class=\"variable\">entity</span> <span class=\"operator\">=</span> response.getEntity();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entity != <span class=\"literal\">null</span> &amp;&amp; response.getStatusLine().getStatusCode() == <span class=\"number\">200</span>) {</span><br><span class=\"line\">                        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> EntityUtils.toString(entity);</span><br><span class=\"line\">                        <span class=\"comment\">//  handle response logic ...</span></span><br><span class=\"line\">                    }</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (IOException e) {</span><br><span class=\"line\">                    log.error(e.getMessage(), e);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (IOException e) {</span><br><span class=\"line\">            log.error(e.getMessage(), e);</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"解決辦法\"><a href=\"#解決辦法\" class=\"headerlink\" title=\"解決辦法\"></a>解決辦法</h2><h3 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h3><p>單次 request 就 重新 new  一個  <code>CloseableHttpClient</code>  。</p>\n<p>然後使用完畢後就 close (try with resources)。這樣的做法為每次進行呼叫 API 都重新進行一次 TCP Connection。</p>\n<p>依照官法文件說法，每次重新建立一個新的 HTTP Client Instance 是成本很高的事情，因此假設程式若有效能需求的情況下。此解決方法可能不盡理想</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.HttpEntity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.http.util.EntityUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpClientExample</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException {</span><br><span class=\"line\">        <span class=\"type\">HttpClientBuilder</span> <span class=\"variable\">httpClientBuilder</span> <span class=\"operator\">=</span> HttpClientBuilder.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; urlList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String url : urlList) {</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"type\">CloseableHttpClient</span> <span class=\"variable\">httpClient</span> <span class=\"operator\">=</span> httpClientBuilder.build()) {</span><br><span class=\"line\">                <span class=\"type\">HttpGet</span> <span class=\"variable\">getRequest</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HttpGet</span>(url);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> (<span class=\"type\">CloseableHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> httpClient.execute(getRequest)) {</span><br><span class=\"line\">                    <span class=\"type\">HttpEntity</span> <span class=\"variable\">entity</span> <span class=\"operator\">=</span> response.getEntity();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (entity != <span class=\"literal\">null</span> &amp;&amp; response.getStatusLine().getStatusCode() == <span class=\"number\">200</span>) {</span><br><span class=\"line\">                        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> EntityUtils.toString(entity);</span><br><span class=\"line\">                        <span class=\"comment\">//  handle response logic ...</span></span><br><span class=\"line\">                    }</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (IOException e) {</span><br><span class=\"line\">                    log.error(e.getMessage(), e);</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">            } <span class=\"keyword\">catch</span> (IOException e) {</span><br><span class=\"line\">                log.error(e.getMessage(), e);</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h3 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h3><p>使用 connection pool 的方式來驗證 connection 是否為 idle connection, 同時也能減少多次呼叫 API 時所吃的資源與效能。</p>\n<p>設定 Connection Pool 參數來定期驗證 TCP Connection 是否為過期或無效的 Connection。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">PoolingHttpClientConnectionManager</span> <span class=\"variable\">cm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PoolingHttpClientConnectionManager</span>();</span><br><span class=\"line\">    cm.setValidateAfterInactivity(<span class=\"number\">500</span>);</span><br><span class=\"line\"><span class=\"type\">CloseableHttpClient</span> <span class=\"variable\">httpclient</span> <span class=\"operator\">=</span> HttpClients.custom()</span><br><span class=\"line\">            .setConnectionManager(cm)</span><br><span class=\"line\">            .evictExpiredConnections()</span><br><span class=\"line\">            .evictIdleConnections(<span class=\"number\">5L</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    \t    .setRetryHandler(DefaultHttpRequestRetryHandler.INSTANCE)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<p>補充說明</p>\n<ul>\n<li><p>max per route : connection manager 預設每個 domain 最大的 connection 數量為 5</p>\n</li>\n<li><p>evictExpiredConnections 與 evictIdleConnections 用於設置在背景中清理過期的 connection</p>\n</li>\n<li><p>setValidateAfterInactivity : 每次取得連線時，假設該連線空閒超過該時間，則會驗證是否可用。默認值為 2000ms</p>\n</li>\n<li><p>設定重試機制：預設試 3 次，但假設 pool 中的 max per route 是五個 connection , 可能還是會出現例外。最好的保險是重是次數需大於 MaxPerRoute , 保證都失效後，重新進行連接</p>\n</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://issues.apache.org/jira/browse/HTTPCLIENT-2282\">Handle java.net.SocketException: Connection reset more gracefully</a></li>\n<li><a href=\"https://www.laitimes.com/article/486os_4ou1m.html\">apache httpclient 連接配接池 工具_HttpClient 連接配接池的一些思考</a></li>\n<li><a href=\"https://www.cnblogs.com/wusanga/p/17392445.html\">HttpClient 连接池的连接淘汰策略分析，以及解决 HttpNoResponse 异常</a></li>\n<li><a href=\"https://stackoverflow.com/questions/70175836/apache-httpclient-throws-java-net-socketexception-connection-reset-if-i-use-it\">Apache HttpClient throws java.net.SocketException: Connection reset if I use it as singletone</a></li>\n<li><a href=\"https://hc.apache.org/httpclient-legacy/performance.html\">HTTP Client</a></li>\n</ul>\n","categories":["Java"],"tags":["Java","HTTP","Apache"]},{"title":"RestTemplate 效能調教","url":"/rest-template-optimize/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>當後端需要跟其他第三方服務、系統溝通時，最常用的方式為透過 Rest API 進行溝通。Spring Boot 專案中，提供了一個好用的<br>call API 工具 - RestTemplate , RestTemplate 提供了簡單的介面簡化了我們呼叫 API 的程式碼。</p>\n<p>但是，RestTemplate 在發送大量請求時往往會發生效能瓶頸，故本篇文章將教學如何進行效能調教來解決 RestTemplate 速度慢的問題。</p>\n<h2 id=\"設定ClientHttpRequestFactory\"><a href=\"#設定ClientHttpRequestFactory\" class=\"headerlink\" title=\"設定ClientHttpRequestFactory\"></a>設定 ClientHttpRequestFactory</h2><p>RestTemplate 底層預設發送 HTTP Request  的工具為使用 HttpURLConnection 來進行發送。此工具未支援 HTTP Connection<br>Pool 來縮短消耗的時間，我們可將其換成現今 Java 有支援 Connection Pool 的工具，像是 OkHttp、Apache HttpClient、<br>WebClient、FeignClient 等等。</p>\n<p>而本篇將採用設定 Apache HttpClient 作為 RestTemplate 發送 HTTP Request 的工具 。</p>\n<p>安裝 dependency</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.httpcomponents<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>httpclient<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.5.13<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span> <span class=\"comment\">&lt;!-- or the latest version --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>建立 HttpComponentsClientHttpRequestFactory 來替換 HTTP Client</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> CloseableHttpClient <span class=\"title function_\">httpClient</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpClientBuilder.create()</span><br><span class=\"line\">            .setMaxConnTotal(<span class=\"number\">100</span>)      <span class=\"comment\">// Set required maximum total connections</span></span><br><span class=\"line\">            .setMaxConnPerRoute(<span class=\"number\">20</span>)    <span class=\"comment\">// Set required maximum connections per route</span></span><br><span class=\"line\">            .build();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">HttpComponentsClientHttpRequestFactory</span>(httpClient()));</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n <br>\n\n<h2 id=\"設定-Connection-Pool-Manager\"><a href=\"#設定-Connection-Pool-Manager\" class=\"headerlink\" title=\"設定 Connection Pool Manager\"></a>設定 Connection Pool Manager</h2><p>在 OSI 網路七層協定中，HTTP 是建構於 TCP 之上的通訊協定，如果每次請求都需要重新建立一次 Connection , 想必會非常的消耗資源 (TCP 三向交握的關係) 。因此 Apache Http Client 提供了 Connection Pool (連線池的機制) 。</p>\n<p>概念上與 AP Server 在跟資料庫連線時的 Connection Pool 類似，都是先 Keep 住 Connection 不立即關閉，等下次有 Request 來時就會借用那個 Connection 來發送請求，大幅減少了每個 Request 都需要花費建立 Connection 的資源 。</p>\n<p>至於如何設定請看下面程式碼說明</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> PoolingHtppClientConnectionManager <span class=\"title function_\">customizedPoolingHtppClientConnectionManager</span><span class=\"params\">()</span>{</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  設定每個Connection 在Connection Pool 中的維持時間 , 範例為 5分鐘 , 此參數須小心設定</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"type\">PoolingHtppClientConnectionManager</span> <span class=\"variable\">connManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PoolingHtppClientConnectionManager</span>(<span class=\"number\">5</span>, TimeUnit.MINUTES);</span><br><span class=\"line\">  connManager.setMaxTotal(<span class=\"number\">100</span>);    <span class=\"comment\">// Set required maximum total connections</span></span><br><span class=\"line\">  connManager.setDefaultMaxPerRoute(<span class=\"number\">20</span>);     <span class=\"comment\">// Set required maximum connections per route</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li><p>max total : connection Pool 最大的總連線數量，預設為 20</p>\n</li>\n<li><p>defaultMaxPerRoute: 每個路徑最大的連線數量，預設為 2</p>\n</li>\n</ul>\n<h2 id=\"設定-Keep-Alive-機制\"><a href=\"#設定-Keep-Alive-機制\" class=\"headerlink\" title=\"設定 Keep Alive  機制\"></a>設定 Keep Alive  機制</h2><p>在 HTTP 中，Keep -Alive 的機制為讓一個 Connection 在一定時間內可以發送多個 Request 。為了避免 server side 已關閉連線，但 client 端卻還是維持該 Connection 的情況 (<strong>Connection Reset by Peer</strong>)。透過設定 Keep -Alive Header 來告知 Http Client Connection 要維持的時間。</p>\n<p> 通常若 server 端未給予 keep alive 的 timeout , 預設可以設定 30 或 60 秒來維持</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> ConnectionKeepAliveStrategy <span class=\"title function_\">connectionKeepAliveStrategy</span><span class=\"params\">()</span> {</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultConnectionKeepAliveStrategy</span>() {</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getKeepAliveDuration</span><span class=\"params\">(HttpResponse response, HttpContext context)</span> {</span><br><span class=\"line\">             <span class=\"type\">long</span> <span class=\"variable\">keepAliveDuration</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getKeepAliveDuration(response, context);</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (keepAliveDuration &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> DEFAULT_KEEP_ALIVE_TIME_MILLIS;</span><br><span class=\"line\">             }</span><br><span class=\"line\">             <span class=\"keyword\">return</span> keepAliveDuration;</span><br><span class=\"line\">         }</span><br><span class=\"line\">     };</span><br><span class=\"line\"> }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>設定排程檢查並關閉 無效 or Idle timeout 的連線</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> Runnable <span class=\"title function_\">idleConnectionMonitor</span><span class=\"params\">(<span class=\"keyword\">final</span> PoolingHttpClientConnectionManager connectionManager)</span> {</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() {</span><br><span class=\"line\">           <span class=\"meta\">@Override</span></span><br><span class=\"line\">           <span class=\"meta\">@Scheduled(fixedDelay = 10000)</span></span><br><span class=\"line\">           <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> {</span><br><span class=\"line\">               <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (connectionManager != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                       LOGGER.trace(<span class=\"string\">\"run IdleConnectionMonitor - Closing expired and idle connections...\"</span>);</span><br><span class=\"line\">                       connectionManager.closeExpiredConnections();</span><br><span class=\"line\">                       connectionManager.closeIdleConnections(CLOSE_IDLE_CONNECTION_WAIT_TIME_SECS, TimeUnit.SECONDS);</span><br><span class=\"line\">                   } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                       LOGGER.trace(<span class=\"string\">\"run IdleConnectionMonitor - Http Client Connection manager is not initialised\"</span>);</span><br><span class=\"line\">                   }</span><br><span class=\"line\">               } <span class=\"keyword\">catch</span> (Exception e) {</span><br><span class=\"line\">                   LOGGER.error(<span class=\"string\">\"run IdleConnectionMonitor - Exception occurred. msg={}, e={}\"</span>, e.getMessage(), e);</span><br><span class=\"line\">               }</span><br><span class=\"line\">           }</span><br><span class=\"line\">       };</span><br><span class=\"line\">   }\t</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"設定請求參數\"><a href=\"#設定請求參數\" class=\"headerlink\" title=\"設定請求參數\"></a>設定請求參數</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> RequestConfig <span class=\"title function_\">requestConfig</span><span class=\"params\">()</span>{</span><br><span class=\"line\">    <span class=\"type\">RequestConfig</span> <span class=\"variable\">requestConfig</span> <span class=\"operator\">=</span></span><br><span class=\"line\">            RequestConfig.custom()</span><br><span class=\"line\">                    .setConnectionRequestTimeout(REQUEST_TIMEOUT)</span><br><span class=\"line\">                    .setConnectTimeout(CONNECT_TIMEOUT)</span><br><span class=\"line\">                    .setSocketTimeout(SOCKET_TIMEOUT)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestConfig;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<ul>\n<li>connection request timeout : client 端從 connection pool 取得連線的最大時效</li>\n<li> connection timeout : 建立連線前的最大時效</li>\n<li> socket timeout : client 等待 server 端回應資料的最大時效</li>\n</ul>\n<h2 id=\"完整設定範例\"><a href=\"#完整設定範例\" class=\"headerlink\" title=\"完整設定範例\"></a>完整設定範例</h2><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Log4j2</span></span><br><span class=\"line\"><span class=\"meta\">@RequiredArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HttpClientConfig</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Determines the timeout in milliseconds until a connection is established.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CONNECT_TIMEOUT</span> <span class=\"operator\">=</span> <span class=\"number\">30000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// The timeout when requesting a connection from the connection manager.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">REQUEST_TIMEOUT</span> <span class=\"operator\">=</span> <span class=\"number\">30000</span>;</span><br><span class=\"line\">    <span class=\"comment\">// The timeout for waiting for data</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SOCKET_TIMEOUT</span> <span class=\"operator\">=</span> <span class=\"number\">60000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_KEEP_ALIVE_TIME_MILLIS</span> <span class=\"operator\">=</span> <span class=\"number\">20</span> * <span class=\"number\">1000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CLOSE_IDLE_CONNECTION_WAIT_TIME_SECS</span> <span class=\"operator\">=</span> <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EnvironmentConfig environmentConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(\"${http.conn-pool.max-total-conn:100}\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer maxTotalConnection;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(\"${http.conn-pool.max-per-route-conn:20}\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer maxPerRouteConnection;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> PoolingHttpClientConnectionManager <span class=\"title function_\">poolingConnectionManager</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">PoolingHttpClientConnectionManager</span> <span class=\"variable\">poolingConnectionManager</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">PoolingHttpClientConnectionManager</span>();</span><br><span class=\"line\">        poolingConnectionManager.setMaxTotal(maxTotalConnection);</span><br><span class=\"line\">        poolingConnectionManager.setDefaultMaxPerRoute(maxPerRouteConnection);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> poolingConnectionManager;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ConnectionKeepAliveStrategy <span class=\"title function_\">connectionKeepAliveStrategy</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultConnectionKeepAliveStrategy</span>() {</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getKeepAliveDuration</span><span class=\"params\">(HttpResponse response, HttpContext context)</span> {</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">keepAliveDuration</span> <span class=\"operator\">=</span> <span class=\"built_in\">super</span>.getKeepAliveDuration(response, context);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (keepAliveDuration &lt; <span class=\"number\">0</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> DEFAULT_KEEP_ALIVE_TIME_MILLIS;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">return</span> keepAliveDuration;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> CloseableHttpClient <span class=\"title function_\">httpClient</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">RequestConfig</span> <span class=\"variable\">requestConfig</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                RequestConfig.custom()</span><br><span class=\"line\">                        .setConnectionRequestTimeout(REQUEST_TIMEOUT)</span><br><span class=\"line\">                        .setConnectTimeout(CONNECT_TIMEOUT)</span><br><span class=\"line\">                        .setSocketTimeout(SOCKET_TIMEOUT)</span><br><span class=\"line\">                        .build();</span><br><span class=\"line\">        <span class=\"type\">DefaultProxyRoutePlanner</span> <span class=\"variable\">proxyRoutePlanner</span> <span class=\"operator\">=</span> proxyRouter();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">HttpClientBuilder</span> <span class=\"variable\">httpClientBuilder</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                HttpClients.custom()</span><br><span class=\"line\">                        .setDefaultRequestConfig(requestConfig)</span><br><span class=\"line\">                        .setConnectionManager(poolingConnectionManager())</span><br><span class=\"line\">                        .setKeepAliveStrategy(connectionKeepAliveStrategy())</span><br><span class=\"line\">                        .setConnectionManagerShared(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (proxyRoutePlanner != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            httpClientBuilder.setRoutePlanner(proxyRoutePlanner);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> httpClientBuilder.build();</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Runnable <span class=\"title function_\">idleConnectionMonitor</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">            <span class=\"keyword\">final</span> PoolingHttpClientConnectionManager connectionManager)</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() {</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"meta\">@Scheduled(fixedDelay = 10000)</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> {</span><br><span class=\"line\">                <span class=\"keyword\">try</span> {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (connectionManager != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                        log.trace(</span><br><span class=\"line\">                                <span class=\"string\">\"run IdleConnectionMonitor - Closing expired and idle connections...\"</span>);</span><br><span class=\"line\">                        connectionManager.closeExpiredConnections();</span><br><span class=\"line\">                        connectionManager.closeIdleConnections(</span><br><span class=\"line\">                                CLOSE_IDLE_CONNECTION_WAIT_TIME_SECS, TimeUnit.SECONDS);</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        log.trace(</span><br><span class=\"line\">                                <span class=\"string\">\"run IdleConnectionMonitor - Http Client Connection manager is not initialised\"</span>);</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                } <span class=\"keyword\">catch</span> (Exception e) {</span><br><span class=\"line\">                    log.error(</span><br><span class=\"line\">                            <span class=\"string\">\"run IdleConnectionMonitor - Exception occurred. msg={}, e={}\"</span>,</span><br><span class=\"line\">                            e.getMessage(),</span><br><span class=\"line\">                            e);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        };</span><br><span class=\"line\">    }</span><br><span class=\"line\"> <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">      設定thread pool ,讓idle monitor的thread 能被執行</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> TaskScheduler <span class=\"title function_\">taskScheduler</span><span class=\"params\">()</span> {</span><br><span class=\"line\">\t\t<span class=\"type\">ThreadPoolTaskScheduler</span> <span class=\"variable\">scheduler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolTaskScheduler</span>();</span><br><span class=\"line\">\t\tscheduler.setThreadNamePrefix(<span class=\"string\">\"poolScheduler\"</span>);</span><br><span class=\"line\">\t\tscheduler.setPoolSize(<span class=\"number\">50</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> scheduler;</span><br><span class=\"line\">\t}</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://hc.apache.org/httpcomponents-client-4.5.x/current/tutorial/html/connmgmt.html\">Apache 官方文件 -  Connection management</a></li>\n<li><a href=\"https://medium.com/starbugs/%E8%AC%8E%E4%B9%8B%E8%81%B2%E5%B0%8D-connection-%E8%AA%AA%E9%81%93-%E4%BD%A0%E5%B7%B2%E7%B6%93%E6%AD%BB%E4%BA%86-b53d27c7ecb7\">謎之聲對 Connection 說道：你已經死了！</a></li>\n<li><a href=\"https://byvoid.com/zht/blog/http-keep-alive-header/\">什麼是 Keep-Alive 模式</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10156092\">[30 天學會 Web 前端效能優化] 5. 淺談 HTTP 協定</a></li>\n<li><a href=\"https://www.baeldung.com/httpclient-connection-management\">Apache HttpClient Connection Management</a></li>\n<li><a href=\"https://howtodoinjava.com/spring-boot2/resttemplate/resttemplate-httpclient-java-config/\">Configuring HttpClient with Spring RestTemplate</a></li>\n<li><a href=\"https://www.dhaval-shah.com/rest-client-with-desired-nfrs-using-springs-resttemplate/\">REST client with desired NFRs using Spring RestTemplate</a></li>\n<li><a href=\"https://medium.com/@nitinvohra/how-to-improve-performance-of-spring-resttemplate-6af37e0a0f33\">How to improve performance of Spring RestTemplate?</a></li>\n<li><a href=\"https://springframework.guru/using-resttemplate-with-apaches-httpclient/\">Using RestTemplate with Apaches HttpClient</a></li>\n<li><a href=\"https://dev.to/akdevcraft/never-use-spring-resttemplate-default-implementation-2ghj\">Avoid Spring RestTemplate Default Implementation to Prevent Performance Impact</a></li>\n<li><a href=\"https://hc.apache.org/httpcomponents-client-4.5.x/current/tutorial/html/connmgmt.html#d5e418\">Apache Http Client Connection Management</a></li>\n</ul>\n","categories":["Spring Boot"],"tags":["Java","Apache","Http","RestTemplate"]},{"title":"Spring 非同步程式設計","url":"/spring-async/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>為了改善應用程式部分功能的效能，像是呼叫多個第三方 API , 資料處理… 等等，往往會用非同步設計的方式達到並行處理的效果。但若採用 Thread, Runbbable ,Callable 這些寫法來實現，會產出許多笨重且較難以維護的程式碼，因此 Spring @Async 來改善程式的可讀性與設計方式。</p>\n<p>本篇會將介紹 Spring @Async 與 Java 8 CompletableFuture 的組合來介紹非同步程式設計的方式。 </p>\n<h2 id=\"概念介紹\"><a href=\"#概念介紹\" class=\"headerlink\" title=\"概念介紹\"></a>概念介紹</h2><p>非同步程式相當於創建一個新的子執行緒 來執行，執行緒 (Thread) 會循序等待每個子執行緒執行完任務，並獲取相關物件值，再次進行相關邏輯運算後，才會回傳最終結果。</p>\n<p>而在 Spring Boot 中，透過 @Async  來標註方法來告知 Spring 需要建立子執行緒來執行，並且在方法回傳該執行緒完成的資料，方法回傳值都透過 Future 實現 。 因此可以結合 JDK 8 推出的 CompletableFuture 功能來做到複雜的商業邏輯處理。</p>\n<h2 id=\"應用時機\"><a href=\"#應用時機\" class=\"headerlink\" title=\"應用時機\"></a>應用時機</h2><p>非同步程式主要是應用於效能優化，但各個資料的狀態互相獨立的場合，一個利用資源換取時間的概念。像是加速批次資料的處理，呼叫多個獨立的 API  端點，資料庫的資料查詢，信件通知等等。</p>\n<h2 id=\"基本啟用設定\"><a href=\"#基本啟用設定\" class=\"headerlink\" title=\"基本啟用設定\"></a>基本啟用設定</h2><p>在配置類別加上 <code>@EnableAsync</code> 啟用非同步方法功能，並建立一個名稱為 <code>executor</code> 的執行緒池。當標註 @Async 時可使用建立好的執行緒來執行非同步方法。 若都未設定 executor , Spring 預設 SimpleAsyncTaskExecutor` 來執行非同步方法。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableAsync</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncConfig</span> {</span><br><span class=\"line\">    <span class=\"meta\">@Value(\"${spring.async.core-pool-size:30}\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(\"${spring.async.max-pool-size:50}\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer maxPoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(\"${spring.async.queue-capacity:80}\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer queueCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = \"taskExecutor\")</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Executor <span class=\"title function_\">executor</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">ThreadPoolTaskExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolTaskExecutor</span>();</span><br><span class=\"line\">        executor.setTaskDecorator(<span class=\"keyword\">new</span> <span class=\"title class_\">MDCTaskDecorator</span>());</span><br><span class=\"line\">        executor.setCorePoolSize(corePoolSize);</span><br><span class=\"line\">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class=\"line\">        executor.setQueueCapacity(queueCapacity);</span><br><span class=\"line\">        executor.setThreadNamePrefix(<span class=\"string\">\"async-\"</span>);</span><br><span class=\"line\">        executor.initialize();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"建立非同步的方法\"><a href=\"#建立非同步的方法\" class=\"headerlink\" title=\"建立非同步的方法\"></a>建立非同步的方法</h2><p>後續在業務邏輯層 (@Service ,@Component) 標註 @Async 來告訴 Spring 該方法是一個非同步執行的任務。若方法需要回傳資料，將資料封裝在 CompletableFuture.completedFuture (results) 進行回傳，方便使用該任務的其他方法做後續的處理 (等待 Thread 執行，額外資料轉換等)。</p>\n<p>程式範例為模擬判斷找到不同字串的電影 。</p>\n<h3 id=\"Service-層\"><a href=\"#Service-層\" class=\"headerlink\" title=\"Service 層\"></a>Service 層</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Collectors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncService</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(AsyncService.class);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> List&lt;String&gt; movies =</span><br><span class=\"line\">      <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(</span><br><span class=\"line\">          Arrays.asList(</span><br><span class=\"line\">              <span class=\"string\">\"Forrest Gump\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Titanic\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Spirited Away\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"The Shawshank Redemption\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Zootopia\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Farewell \"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Joker\"</span>,</span><br><span class=\"line\">              <span class=\"string\">\"Crawl\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Async</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> CompletableFuture&lt;List&lt;String&gt;&gt; <span class=\"title function_\">completableFutureTask</span><span class=\"params\">(String start)</span> {</span><br><span class=\"line\">    logger.warn(Thread.currentThread().getName() + <span class=\"string\">\"start this task!\"</span>);</span><br><span class=\"line\">    List&lt;String&gt; results =</span><br><span class=\"line\">        movies.stream().filter(movie -&gt; movie.startsWith(start)).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">1000L</span>);</span><br><span class=\"line\">    } <span class=\"keyword\">catch</span> (InterruptedException e) {</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CompletableFuture.completedFuture(results);</span><br><span class=\"line\">  }    </span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"Controller-層\"><a href=\"#Controller-層\" class=\"headerlink\" title=\"Controller 層\"></a>Controller 層</h3><p>建立一個 API 端點來測試撰寫的非同步方法是不是用不同的 Thread 來處理資料。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(\"/async\")</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AsyncController</span> {</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span> </span><br><span class=\"line\">  AsyncService asyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@GetMapping(\"/movies\")</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String <span class=\"title function_\">completableFutureTask</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException {</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">    List&lt;String&gt; words = Arrays.asList(<span class=\"string\">\"F\"</span>, <span class=\"string\">\"T\"</span>, <span class=\"string\">\"S\"</span>, <span class=\"string\">\"Z\"</span>, <span class=\"string\">\"J\"</span>, <span class=\"string\">\"C\"</span>);</span><br><span class=\"line\">    List&lt;CompletableFuture&lt;List&lt;String&gt;&gt;&gt; completableFutureList =</span><br><span class=\"line\">        words.stream()</span><br><span class=\"line\">            .map(word -&gt; asyncService.completableFutureTask(word))</span><br><span class=\"line\">            .collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// CompletableFuture.join（）</span></span><br><span class=\"line\">    List&lt;List&lt;String&gt;&gt; results = completableFutureList.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// print consume time</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Elapsed time: \"</span> + (System.currentTimeMillis() - start));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results.toString();</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>啟動應用程式後，Postman 或瀏覽器對 <code>http://localhost:8080/async/movies</code> 發出 <code>GET</code> 請求。</p>\n<p>應用程式收到請求並執行後會在 console 印出下面結果。可以觀察到該端點會新增不同的執行緒來實現非同步執行。</p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\">My ThreadPoolTaskExecutor-1start this task!</span><br><span class=\"line\">My ThreadPoolTaskExecutor-6start this task!</span><br><span class=\"line\">My ThreadPoolTaskExecutor-5start this task!</span><br><span class=\"line\">My ThreadPoolTaskExecutor-4start this task!</span><br><span class=\"line\">My ThreadPoolTaskExecutor-3start this task!</span><br><span class=\"line\">My ThreadPoolTaskExecutor-2start this task!</span><br><span class=\"line\">Elapsed time: 1010</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>此篇文章簡單介紹了 SpringBoot 如何改善複雜的非同步程式設計，並介紹如何啟用 Spring Boot 非同步的功能，並如何實際開發出非同步的程式，最後則是有一個小小的 Demo 來顯示非同步的功能是如何啟用的，至於如何處理回傳的 CompletableFuture , 筆者後續會再詳細介紹有哪些語法可以使用！！！</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://www.tpisoftware.com/tpu/articleDetails/1484\">JDK8 - CompletableFuture 非同步處理簡介</a></li>\n<li><a href=\"https://www.baeldung.com/spring-async\">How To Do @Async in Spring</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/2020/06/spring-boot-async-methods-example.html\">Spring Boot @Async 非同步方法範例</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10278638?sc=iThelpR\">今晚我想來個 Spring Async 非同步的感覺</a></li>\n<li><a href=\"https://popcornylu.gitbooks.io/java_multithread/content/async/cfuture.html\">CompletableFuture</a></li>\n<li><a href=\"https://www.javadoop.com/post/completable-future\">CompletableFuture 使用介绍</a></li>\n<li><a href=\"https://github.com/CodingDocs/springboot-guide/blob/master/docs/advanced/springboot-async.md\">新手也能看懂的 SpringBoot 异步编程指南</a></li>\n</ul>\n","categories":["Spring"],"tags":["Java","Async","Spring Boot"]},{"title":"SpringBoot i18n 國際化設定","url":"/spring-boot-i18n/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"多語系網站的好處\"><a href=\"#多語系網站的好處\" class=\"headerlink\" title=\"多語系網站的好處\"></a><strong>多語系網站的好處</strong></h3><p>在網路世界裡，使用者沒辦法親眼看到公司實際的樣子，官網就是一個形象的展現，網站有不同的語系除了更顯國際化，頁面的瀏覽上也顯得更親切；<br>對很多人來說，使用自己不熟悉的語言，會感覺陌生，容易產生不信任感。若能讓潛在客戶使用自己語言瀏覽網站，也能讓訪客覺得這家公司是一間相當有規模的公司，提高在網站上的體驗，也有機會提高轉化率。</p>\n<h3 id=\"Spring-Boot-多語系介紹-環境配置\"><a href=\"#Spring-Boot-多語系介紹-環境配置\" class=\"headerlink\" title=\"Spring Boot 多語系介紹, 環境配置\"></a>Spring Boot 多語系介紹，環境配置</h3><p>Spring Boot 自動配置 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/MessageSource.html\">MessageSource</a> 做 i18n 多國語言訊息，不用再自己配置 <code>MessageSource</code> 的 bean 且預設會尋找 classpath 根目錄下名稱為 messages 的 properties 作為訊息來源。 如果想要使用其他名稱或路徑，可在 Spring Boot 配置檔 application.properties 設定。</p>\n<h3 id=\"套件安裝\"><a href=\"#套件安裝\" class=\"headerlink\" title=\"套件安裝\"></a>套件安裝</h3><p>springBoot 對 i18n 的支援是含在 <code>spring-context-support</code> 裡的，因此僅需引用 <em>web-starter</em>  模組，不需要再額外引用其他的 <code>xxx - starter</code></p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">implementation</span> <span class=\"string\">'org.springframework.boot:spring-boot-starter-web'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"系統設定\"><a href=\"#系統設定\" class=\"headerlink\" title=\"系統設定\"></a>系統設定</h2><ol>\n<li><h3 id=\"設定Message-Source-讀取位置\"><a href=\"#設定Message-Source-讀取位置\" class=\"headerlink\" title=\"設定Message Source 讀取位置\"></a>設定 Message Source 讀取位置</h3><p>在 spring boot 中，需要在 properties 設定讀取建立的 Message 檔案路徑位置 。</p>\n<p>application.properties</p>\n<figure class=\"highlight properties\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.messages.basename</span>=<span class=\"string\">i18n/messages</span></span><br><span class=\"line\"><span class=\"attr\">spring.messages.encoding</span>=<span class=\"string\">UTF-8</span></span><br><span class=\"line\"><span class=\"attr\">spring.messages.cache-duration</span>=<span class=\"string\">3600</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>預設會是 basename 代表語系檔的路徑以及檔名，依照這裡的設定須將語系檔放在 resource/i18n 之下，且命名為 message.properties</p>\n<ul>\n<li>message_zh_TW . properties</li>\n<li>message_en_US . properties</li>\n<li>message.properties</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://i.imgur.com/e3HHl7o.png\"></p>\n<ol start=\"2\">\n<li><h3 id=\"設定解析器-Resolver-與攔截器-Interceptor\"><a href=\"#設定解析器-Resolver-與攔截器-Interceptor\" class=\"headerlink\" title=\"設定解析器(Resolver)與攔截器 (Interceptor)\"></a> 設定解析器 (Resolver) 與攔截器 (Interceptor)</h3><p>如果不想使用用設的 <a href=\"https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceAutoConfiguration.java\"><em>MessageSourceAutoConfiguration</em></a>  。  </p>\n<p>可以自行客製化設定解析語系名稱的清單，語系暫存的位置 以及要如何切換語系的方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocaleConfig</span> {</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReloadableResourceBundleMessageSource <span class=\"title function_\">messageSource</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">ReloadableResourceBundleMessageSource</span> <span class=\"variable\">messageSource</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReloadableResourceBundleMessageSource</span>();</span><br><span class=\"line\">        messageSource.setBasename(<span class=\"string\">\"classpath:i18n/messages\"</span>);</span><br><span class=\"line\">        messageSource.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        messageSource.setCacheSeconds(<span class=\"number\">3600</span>); <span class=\"comment\">// Cache for an hour</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageSource;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Spring Boot 預設採用 AcceptHeader Resolver</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocaleResolver <span class=\"title function_\">localeResolver</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 設定支援的 Locales，若 Accept-Language 沒設定或不在這清單內就會使用預設的 Locale</span></span><br><span class=\"line\">        List&lt;Locale&gt; supportedLocales = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        supportedLocales.add(Locale.TAIWAN);</span><br><span class=\"line\">        supportedLocales.add(Locale.ENGLISH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">AcceptHeaderLocaleResolver</span> <span class=\"variable\">acceptHeaderLocaleResolver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AcceptHeaderLocaleResolver</span>();</span><br><span class=\"line\">        acceptHeaderLocaleResolver.setDefaultLocale(Locale.TAIWAN); <span class=\"comment\">// 預設 Locale</span></span><br><span class=\"line\">        acceptHeaderLocaleResolver.setSupportedLocales(supportedLocales);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acceptHeaderLocaleResolver;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 默認攔截器 客製化設定切換語系時的參數名.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocaleChangeInterceptor <span class=\"title function_\">localeChangeInterceptor</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">LocaleChangeInterceptor</span> <span class=\"variable\">lci</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocaleChangeInterceptor</span>();</span><br><span class=\"line\">        lci.setParamName(<span class=\"string\">\"lang\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lci;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span>{</span><br><span class=\"line\">        registry.addInterceptor(localeChangeInterceptor());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<p>程式中是使用 AcceptHeaderLocaleResolver 來提取當前 Client 想用的語系，其實還有其他常見的解析方式</p>\n<table>\n<thead>\n<tr>\n<th>Locale Resolver</th>\n<th> 說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong> CookieLocaleResolver</strong></td>\n<td> 將使用者的語系偏好資料暫存於 瀏覽器的 Cookie 中</td>\n</tr>\n<tr>\n<td><strong> SessionLocaleResolver</strong></td>\n<td> 將使用者的語系偏好資料暫存於 Session 中</td>\n</tr>\n<tr>\n<td><strong> FixedLocaleResolver</strong></td>\n<td> 固定當前的語系，不會依照使用者設定的語系偏好改變，用於 Debug</td>\n</tr>\n</tbody></table>\n<br></li>\n</ol>\n<h2 id=\"讀取Locale-Message\"><a href=\"#讀取Locale-Message\" class=\"headerlink\" title=\"讀取Locale Message\"></a>讀取 Locale Message</h2><p>當設定完成後，若要在程式讀取設定的訊息，可注入 <code>MessageSource</code> 的資源，透過 key 值去對應訊息，</p>\n<p>如果後面帶入的語系不存在就會用預設的 message.properties 內容</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoController</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MessageSource messageSource;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(\"/{userId}\")</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus(HttpStatus.OK)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getOneUser</span><span class=\"params\">(<span class=\"meta\">@PathVariable(\"userId\")</span> Long userId)</span> <span class=\"keyword\">throws</span> Exception {</span><br><span class=\"line\">        Optional&lt;User&gt; userOption = userDao.findById(userId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userOption.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> messageSource.getMessage(</span><br><span class=\"line\">                <span class=\"string\">\"user.controller.not.found.by.id\"</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]{userId.toString()},</span><br><span class=\"line\">                Locale.TAIWAN);</span><br><span class=\"line\">            log.error(msg);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userOption.get();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的範例是直接寫入 Locale.TAIWAN 來套用語系，實際情境下通常是透過 API 帶入語系參數來決定訊息的語系，</p>\n<p>因此可以改寫成</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @param code: 設定要取Message 的Key</span></span><br><span class=\"line\"><span class=\"comment\">// @param args: 作為變數替換Message 中的區塊</span></span><br><span class=\"line\"><span class=\"comment\">// @param Locale: 讀取Message 的語系檔</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> messageSource.getMessage(<span class=\"string\">\"user.controller.not.found.by.id\"</span>,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]{userId.toString()}, LocaleContextHolder.getLocale())</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>LocaleContextHolder.getLocale()</code> 會從 request 的 header 欄位 Accept-Language 來解析語系。</p>\n<p>如果語系找不到會先抓主機的預設語系，若預設語系也不存在才會去抓 <code>message.properties</code></p>\n<h3 id=\"Message-參數化\"><a href=\"#Message-參數化\" class=\"headerlink\" title=\"Message 參數化\"></a><strong>Message 參數化</strong></h3><p>Message 支援帶入程式的變數來動態替換訊息，在訊息來源檔中的要嵌入的變數位置，將變數傳入至 <code>MessageSource.getMessage()</code> 的第二個參數做替換</p>\n<figure class=\"highlight properties\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">demo.message</span>=<span class=\"string\">MessageSource自動配置</span></span><br><span class=\"line\"><span class=\"attr\">demo.message.args</span>=<span class=\"string\">帶參數的訊息，參數0={0}, 參數1={1}</span></span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"建立成共用元件\"><a href=\"#建立成共用元件\" class=\"headerlink\" title=\"建立成共用元件\"></a>建立成共用元件</h2><p>使用原生的語法來取 message 比較不方便，而且而且語系的參數基本上就是帶入 <code>LocaleContextHolder.getLocale()</code>。 </p>\n<p>因此將使用 <code>MessageSource</code> 的邏輯封裝成 Utils 來簡化程式碼</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocaleUtils</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MessageSource messageSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LocaleUtils</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMessageSource</span><span class=\"params\">(MessageSource messageSource)</span> {</span><br><span class=\"line\">        LocaleUtils.messageSource = messageSource;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">get</span><span class=\"params\">(String msgKey)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleUtils.get(msgKey, (Object) <span class=\"literal\">null</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">get</span><span class=\"params\">(String msgKey, Object... args)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> messageSource.getMessage(msgKey, args, getLocale());</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (Exception e) {</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InternalServerErrorException</span>(<span class=\"string\">\"翻譯失敗:\"</span> + msgKey + <span class=\"string\">\", \"</span> + e.getMessage());</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageDTO <span class=\"title function_\">getMessage</span><span class=\"params\">(String msgKey)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleUtils.getMessage(msgKey, (Object) <span class=\"literal\">null</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageDTO <span class=\"title function_\">getMessage</span><span class=\"params\">(String msgKey, Object... args)</span> {</span><br><span class=\"line\">        <span class=\"type\">MessageDTO</span> <span class=\"variable\">messageDTO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageDTO</span>();</span><br><span class=\"line\">        messageDTO.setMessage(LocaleUtils.get(msgKey, args, getLocale()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageDTO;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Locale <span class=\"title function_\">getLocale</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleContextHolder.getLocale();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://bingdoal.github.io/backend/2021/12/i18n-internationalization-in-spring-boot/\">Spring boot 的 I18n 設定與進一步包裝</a></li>\n<li><a href=\"https://www.tpisoftware.com/tpu/articleDetails/2347\">Spring Boot 快速配置多語系 (國際化)</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/2020/06/spring-boot-messagesource-i18n-example.html\">Spring Boot MessageSource i18n 範例</a></li>\n<li><a href=\"https://polinwei.com/spring-boot-i18n/\">Spring Boot 多語系設置 (i18n – 國際化)</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/2020/06/spring-boot-messagesource-auto-config.html\">Spring Boot MessageSource 自動配置</a></li>\n<li><a href=\"https://www.baeldung.com/spring-boot-internationalization\">Guide to Internationalization in Spring Boot |Baledung</a></li>\n<li><a href=\"https://reflectoring.io/spring-boot-internationalization/\">How to Internationalize a Spring Boot Application</a></li>\n<li><a href=\"https://lokalise.com/blog/spring-boot-internationalization/\">Spring Boot internationalization i18n: Step-by-step with examples</a></li>\n<li><a href=\"https://howtodoinjava.com/spring-boot/rest-i18n-example/\">Spring Boot REST: Internationalization (i18n) Example</a></li>\n</ul>\n","categories":["Spring Boot"],"tags":["Java","Spring Boot","i18n"]},{"title":"Spring Boot 重試機制","url":"/spring-boot-retry/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在網路應用程式中，可能會發生一些情境，例如：傳送訊息失敗，呼叫遠端服務忙碌，網路不穩定，等等…  這些程式突然異常的狀況往往讓他自動重試可能就正常了。因此在 Spring Boot 中，提供 Spring Retry 的 Module 幫助我們實現重試與復原的機制，讓撰寫的功能更加穩定，並且簡化實現重試機制的程式碼。</p>\n<h2 id=\"Spring-Retry-設定\"><a href=\"#Spring-Retry-設定\" class=\"headerlink\" title=\"Spring Retry 設定\"></a>Spring Retry 設定</h2><h3 id=\"安裝spring-retry\"><a href=\"#安裝spring-retry\" class=\"headerlink\" title=\"安裝spring retry\"></a>安裝 spring retry</h3><p>spring retry 是基於 AOP 的方式來實現的功能，因此在安裝時需引入 AOP 相關套件</p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.retry<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-retry<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"啟用Spring-Retry\"><a href=\"#啟用Spring-Retry\" class=\"headerlink\" title=\"啟用Spring Retry\"></a>啟用 Spring Retry</h3><p>再 @Configuration class 上使用 @EnableRetry </p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableRetry</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RetryConfig</span> { ... }</span><br></pre></td></tr></tbody></table></figure>\n\n<p>或主程式上使用</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableRetry</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoApplication</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> {</span><br><span class=\"line\">      SpringApplication.run(DemoApplication.class, args);</span><br><span class=\"line\">   }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"使用-Retryable-實現重試機制\"><a href=\"#使用-Retryable-實現重試機制\" class=\"headerlink\" title=\"使用 @Retryable 實現重試機制\"></a>使用 @Retryable 實現重試機制</h2><p>使用 @Retryable 非常簡單，只需要在要進行重試的方法上添加 @Retryable 注解，然後設置相關的重試參數即可。但由於底層使用 AOP 的概念實作，因此重試機制只適用於 Spring 管理的 Bean 物件上，並且在同個 Class 中被呼叫的話也會失效。</p>\n<h3 id=\"Retryable的參數介紹\"><a href=\"#Retryable的參數介紹\" class=\"headerlink\" title=\"@Retryable的參數介紹\"></a>@Retryable 的參數介紹</h3><ol>\n<li>value：指定需要重試的異常類型。如果沒有指定，則默認重試所有異常。可以指定多個異常類型，以陣列的形式提供。</li>\n<li>maxAttempts：指定最多重試次數。默認值為 3。</li>\n<li>backoff：指定重試間隔時間。可以指定一個 @Backoff 註釋對象，這個對象有兩個屬性：<ul>\n<li>delay：指定重試間隔時間，默認為 0 毫秒。</li>\n<li>multiplier：指定每次重試的間隔時間增加倍數，默認為 1。</li>\n</ul>\n</li>\n<li>include：指定需要重試的異常類型。與 value 類似，但是是針對於某些異常類型進行重試。</li>\n<li>exclude：指定不需要重試的異常類型。與 value 類似，但是是針對於某些異常類型不進行重試。</li>\n</ol>\n<h3 id=\"使用方法與範例\"><a href=\"#使用方法與範例\" class=\"headerlink\" title=\"使用方法與範例\"></a>使用方法與範例</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retryable(value = {RestClientException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ResponseEntity&lt;String&gt; <span class=\"title function_\">sendRequest</span><span class=\"params\">(String url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;String&gt; responseType)</span> <span class=\"keyword\">throws</span> RestClientException {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> restTemplate.exchange(url, method, requestEntity, responseType);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的範例中，當方法拋出為 RestClientException 時，Spring Retry 會再次呼叫該方法，最多執行 3 次，並且每次間隔 1000 ms 來進行重試。</p>\n<h3 id=\"Recover\"><a href=\"#Recover\" class=\"headerlink\" title=\"@Recover\"></a>@Recover</h3><p>當重試至最大的次數時卻還是未成功，可能會需要額外執行的後備方案來進行錯誤處理，像是 紀錄錯誤 Log , 將失敗資訊寫入資料庫，資料庫的交易 Roll back 等等 。</p>\n<p>因此 Spring Boot 提供 @Recover 功能提供開發人員撰寫復原的方案機制。</p>\n<blockquote>\n<p>該 @Recover 的 method 參數與回傳直需要與重試的相同才會被呼叫 </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Recover</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ResponseEntity&lt;String&gt; <span class=\"title function_\">recover</span><span class=\"params\">(RestClientException e)</span> {</span><br><span class=\"line\">\tlogger.error(<span class=\"string\">\"Recover...\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// fallback implementation</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"使用-RetryTemplate-進行重試\"><a href=\"#使用-RetryTemplate-進行重試\" class=\"headerlink\" title=\"使用 RetryTemplate 進行重試\"></a>使用 RetryTemplate 進行重試</h2><p>如果想要要同一個 @Bean class 中的 Method 使用 retry 機制，可以透過 RetryTemplate 來開發。</p>\n<h3 id=\"設定Retry-Template的重試機制\"><a href=\"#設定Retry-Template的重試機制\" class=\"headerlink\" title=\"設定Retry Template的重試機制\"></a>設定 Retry Template 的重試機制</h3><figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableRetry</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RetryConfig</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> RetryTemplate <span class=\"title function_\">retryTemplate</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"type\">RetryTemplate</span> <span class=\"variable\">retryTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RetryTemplate</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Fixed delay of 1 second between retries</span></span><br><span class=\"line\">    <span class=\"type\">FixedBackOffPolicy</span> <span class=\"variable\">fixedBackOffPolicy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FixedBackOffPolicy</span>();</span><br><span class=\"line\">    fixedBackOffPolicy.setBackOffPeriod(<span class=\"number\">1000l</span>);</span><br><span class=\"line\">    retryTemplate.setBackOffPolicy(fixedBackOffPolicy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Retry only 3 times</span></span><br><span class=\"line\">    <span class=\"type\">SimpleRetryPolicy</span> <span class=\"variable\">retryPolicy</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleRetryPolicy</span>();</span><br><span class=\"line\">    retryPolicy.setMaxAttempts(<span class=\"number\">3</span>);</span><br><span class=\"line\">    retryTemplate.setRetryPolicy(retryPolicy);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> retryTemplate;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"RetryTemplate-使用範例\"><a href=\"#RetryTemplate-使用範例\" class=\"headerlink\" title=\"RetryTemplate  使用範例\"></a>RetryTemplate  使用範例</h3><p>透過注入 RetryTemplate , 並將想要重試的程式碼區塊利用 Lambda 語法作為 RetryTemplate.execute () 的參數來實現</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">RetryTemplate retryTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">template.execute(ctx -&gt; {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> backendAdapter.getBackendResponse(...);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure>\n\n\n<h2 id=\"Retryable-失效的原因\"><a href=\"#Retryable-失效的原因\" class=\"headerlink\" title=\"Retryable 失效的原因\"></a>Retryable 失效的原因</h2><p>假設發現 <code>@Retryable</code> 不生效，可能有以下一些原因：</p>\n<ol>\n<li>忘記加上 <code>@EnableRetry</code> 注解：在 Spring Boot 中，如果想要使用 <code>@Retryable</code> 注解，必須在 Spring 配置類上加上 <code>@EnableRetry</code> 注解，啟用 Spring Retry 的支持。</li>\n<li>未 include 到例外 ：如果在 <code>@Retryable</code> 注解中指定的例外類型與方法中抛出的例外不相符，那麼重試操作就不會發生，可以嘗試在 <code>@Retryable</code> 注解中新增需要重試的例外類型。</li>\n<li>重試策略設定錯誤：Spring Retry 預設的重試策略是重試 3 次，每次重試之間等待 1 秒。如果需要自定義重試策略，可以實現 <code>RetryPolicy</code> 接口，並在 <code>@Retryable</code> 注解中指定重試策略。</li>\n<li>事務設定錯誤：如果被 <code>@Retryable</code> 注解標註的方法中包含事務操作，那麼可能需要進一步設定事務管理器以支援重試操作。</li>\n<li>不在 Spring 管理的 Bean 上使用：<code>@Retryable</code> Annotation 只能用於 Spring 管理的物件上，如果在非 Spring 管理的物件上使用，則重試操作不會生效。</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://www.tpisoftware.com/tpu/articleDetails/1407\">spring-retry 重試機制</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10191550\">如何在 SpringBoot 中使用 Retry &amp; Cache</a></li>\n<li><a href=\"https://carger.tips/java-spring-boot-retryable-%E9%87%8D%E8%A9%A6%E6%A9%9F%E5%88%B6\">Java Spring Boot – @Retryable 重試機制</a></li>\n<li><a href=\"https://howtodoinjava.com/spring-boot2/spring-retry-module/\">Spring Boot Retry Example</a></li>\n<li><a href=\"https://www.baeldung.com/spring-retry\">Guide to Spring Retry</a></li>\n<li><a href=\"https://bootcamptoprod.com/spring-boot-retry/\">Spring Boot Retry: How to Handle Errors and Retries in Your Application</a></li>\n</ul>\n","categories":["Spring Boot"],"tags":["Java","Spring Boot"]},{"title":"學習單元測試 - 基本觀念","url":"/unit-test-basic/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>單元測試的目的在於測試每個 class 的 function 是不是如期運轉，故撰寫目的在於測試在 A 情境 (test case) 下的<br>Input/Output 是不是如預期所想的。透過寫單元測試，也能幫助我們設計程式的撰寫習慣，避免利用一個 function 封裝全部的業務邏輯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"單元測試流程\"><a href=\"#單元測試流程\" class=\"headerlink\" title=\"單元測試流程\"></a>單元測試流程</h2><ol>\n<li>釐清對象</li>\n<li>設計測試案例 (Test case)</li>\n<li> 測試環境準備 (JUnit)</li>\n<li> 相依物件隔離 (Test Double &amp; Mockito)</li>\n<li> 測試結果 (JUnit &amp; AssertJ &amp; Mockito)</li>\n</ol>\n<h2 id=\"釐清對象與設計測試案例\"><a href=\"#釐清對象與設計測試案例\" class=\"headerlink\" title=\"釐清對象與設計測試案例\"></a>釐清對象與設計測試案例</h2><p>首先，撰寫單元測試前，需先釐清 SUT , DOC 的名詞概念意義 :</p>\n<ul>\n<li>System under test (SUT)  : 要進行功能測試的元件 (Class)</li>\n<li>Depended On Component (DOC) :  測試物件所需要用到其他功能的元件  (Class)</li>\n</ul>\n<p>因此在概念上，僅需思考 SUT 的元件是誰，以及要如何進行測試，其餘 SUT 裡面用到的 DOC 元件則是需要將它進行隔絕。 </p>\n<p>這些 DOC 元件則會在他們的單元測試中測試，只要 DOC 在自己的單元測試沒問題，那在 SUT 裡也不會有問題。</p>\n<p>找出了 SUT, 就可以開始根據 SUT 設計相對應的 <strong>測試案例 (Test Case)</strong> , 為了確保功能的完整性，需設計多個測試案例來測試功能。</p>\n<blockquote>\n<p>測試案例的準則為，只要該物件的輸入不同，結果也是不同的情況，基本上就能拆分出一個測試案例。</p>\n</blockquote>\n<p>舉例來說，代測功能中具有處理例外的情況，此時例外情況通常輸入的值會與正常時不同。<br>因此例外與正常執行的情況皆為不同的<strong>測試案例 (Test case)。</strong></p>\n<p>而 Test Case 的設計大多會 Follow 3A Pattern，如下:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethodNameReturnWhat</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"comment\">//Arrange    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//Act   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">//Assert</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>測試方法的命名方式為 test + 測試的方法 + 預期回傳值。 執行內容為測試內容的準備 (Arrange)  / 執行 (Act)  / 驗證 (Assert)。</p>\n<ul>\n<li><p>Arrange : 預先設計測試案例 的輸入資料為何，包含一些測試替身 等。</p>\n</li>\n<li><p>Act :  如何執行要測試的功能之實作部分</p>\n</li>\n<li><p>Assert: 驗證該方法輸出的資料是否符合預期 or 方始使用 DOC 的次數等等</p>\n</li>\n</ul>\n<h2 id=\"測試環境準備-JUnit\"><a href=\"#測試環境準備-JUnit\" class=\"headerlink\" title=\"測試環境準備( JUnit )\"></a>測試環境準備 (JUnit)</h2><p>當開始執行測試時，需要做的事前準備輸出報告 (測試案例成功與否) 與環境 (是否要先準備假資料，或是啟動 Web container)，<br>與當結束後是否要進行清理 (可能測試寫檔需要刪除測試產生的檔案)，這個環節 Java 通常都使用 JUnit 套件輔助撰寫，<br>在後面的系列文會有詳細的 JUnit 介紹。</p>\n<h2 id=\"相依物件隔離-Test-Double-＆-Mockito\"><a href=\"#相依物件隔離-Test-Double-＆-Mockito\" class=\"headerlink\" title=\"相依物件隔離(Test Double ＆ Mockito)\"></a>相依物件隔離 (Test Double ＆ Mockito)</h2><p>為了不讓 DOC 物件影響 SUT 測試的結果，故需要使用隔離方法來排除使用的 DOC 物件。</p>\n<p>通常隔離的概念為建立 Test Double (測試替身), 而隔離的 DOC 因為被使用的功能主要分為兩類:</p>\n<p><strong>Dummy — 取代不在乎細節的物件</strong></p>\n<p>在實作時，有些物件只會關注數量，存不存在，其物件的內容並不會影響測試案例，此時就適合使用 Dummy 物件來取代，<br>減少建立原本物件的繁瑣操作。</p>\n<p><strong>Stub — 讓 DOC 提供 SUT 想要的 Input/Output 的物件</strong><br>Stub 則是與 Dummy 不同，實作的內容會影響到測試案例的結果，為了測試程式中不同的邏輯，<br>需要讓 Stub 物件設定輸出不同的值</p>\n<p>而產生測試替身的方法主要分為三種:</p>\n<p><strong>Mock — 都是假的</strong><br>由於 Stub 物件會影響我們的測試結果，故利用 Mock 的方式來模擬，<br>故需要設定我們輸入的值以及對應預期測試情境下要輸出的值來進行替換。</p>\n<p><strong>Spy — 監控 DOC 與 SUT 的互動</strong><br>Spy 主要功能為用來檢視 Mock 與 DOC 之間的交互作用。</p>\n<p><strong>Fake — 環境有限制我只好在寫一個</strong><br>其實有 Mock 和 SPY 方法在單元測試就涵蓋了 99% 的覆蓋了，而 Fake 就是真實寫一個簡單的邏輯取代原本得邏輯<br>(Mock 和 Spy 都是直接輸出需要的值 Fake 則要寫邏輯)，舉例：Database 的使用，在單元測試使用 H2 (In-memory database)<br>，或是在內網開發環境不能使用外網時，SSL 憑證檢查工具可以寫一個 Fake，改寫成去讀隨機以準備好在 Resource 的憑證.txt</p>\n<blockquote>\n<p>以上三種建立測試替身的方法是可以同時使用的，例如對 DOC 做 Mock 再做 SPY，模擬加上監控，<br>也可以對 Fake 做 Mock 只取其中幾個邏輯做模擬，其他方法用簡單的邏輯實踐。<br>請避免搞混 Mock / Spy / Fake 的概念。</p>\n</blockquote>\n<h2 id=\"測試結果-JUnit-AssertJ-Mockito\"><a href=\"#測試結果-JUnit-AssertJ-Mockito\" class=\"headerlink\" title=\"測試結果 (JUnit / AssertJ / Mockito)\"></a>測試結果 (JUnit / AssertJ / Mockito)</h2><p>當測試環境，案例，Test double 的模擬方式都定義好了，<br>需要確認這樣的情境下所執行的結果是不是如同我們的預期，藉此來驗證有效性。</p>\n<p><strong>測試結果通常會聚焦在三點:</strong></p>\n<ol>\n<li>待測目標 (SUT) 的輸出結果是否符合預期</li>\n<li>相依物件 (DOC) 是否有符合預期的被呼叫，而呼叫次數是否準確</li>\n<li>整個 Test Case 是否有涵蓋到完整的 SUT?</li>\n</ol>\n<p>前兩點，在 Java 會透過 JUnit / AssertJ / Mockito 協助完成，<br>而第三點我們就要討論到 Unit Test 很重要的觀念，覆蓋率。</p>\n<p>覆蓋率就是單元測試執行結束後，SUT 有多少行程式碼有執行到，而執行到的程式碼 / 全部程式碼的百分比就是覆蓋率。<br>而覆蓋率也細分了一些種類，這邊只列三個基本的介紹</p>\n<ol>\n<li>Statement coverage — 程式碼每一行覆蓋</li>\n<li> Branch coverage — SUT 中的每個 if else 是不是都有進去過</li>\n<li> Condition coverage — 每個會產生 true or false 的判斷是不是都有跑到過</li>\n</ol>\n<p>Branch 和 Condition 常常會搞混，直接看個範例</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; b || b &gt; c) {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的程式碼，if 其實只要做到 a &gt; b 就可以進入，這是 Branch coverage，<br>而 Condition Coverage 則是 a &gt; b || b &gt; c 的這兩個條件都要跑到過才能算是覆蓋成功。</p>\n<p>最常用的覆蓋率工具 (IDEA/JaCoCo) 在計算覆蓋率的部分其實沒有上面如此複雜，<br>白話文就是參考以下概念進行計算：</p>\n<ol>\n<li>Class - 系統裡多少 Class 被跑到</li>\n<li> Function - Class 裡多少 Function 被跑到</li>\n<li> Line - Function 裡多少程式被跑到</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://medium.com/bucketing/java-test-1-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E7%AF%87-unit-test-c9c398c27d39\">Java Test#1 單元測試概念篇</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/search?q=%E6%B8%AC%E8%A9%A6\">菜鳥工程師 - 肉豬 - 測試</a></li>\n</ul>\n","categories":["Test"],"tags":["Unit Test"]}]